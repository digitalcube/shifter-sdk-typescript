/* tslint:disable */
/* eslint-disable */
/**
 * Shifter API
 * Shifter API
 *
 * The version of the OpenAPI document: latest
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AccountLogAuthEventsEventContextData
 */
export interface AccountLogAuthEventsEventContextData {
    /**
     * 
     * @type {string}
     * @memberof AccountLogAuthEventsEventContextData
     */
    IPAddress?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountLogAuthEventsEventContextData
     */
    DeviceName?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountLogAuthEventsEventContextData
     */
    Timezone?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountLogAuthEventsEventContextData
     */
    City?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountLogAuthEventsEventContextData
     */
    Country?: string;
}
/**
 * 
 * @export
 * @interface AccountLogAuthEventsEventFeedback
 */
export interface AccountLogAuthEventsEventFeedback {
    /**
     * 
     * @type {string}
     * @memberof AccountLogAuthEventsEventFeedback
     */
    FeedbackValue?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountLogAuthEventsEventFeedback
     */
    Provider?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountLogAuthEventsEventFeedback
     */
    FeedbackDate?: string;
}
/**
 * 
 * @export
 * @interface AccountLogAuthEventsEventRisk
 */
export interface AccountLogAuthEventsEventRisk {
    /**
     * 
     * @type {string}
     * @memberof AccountLogAuthEventsEventRisk
     */
    RiskDecision?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountLogAuthEventsEventRisk
     */
    RiskLevel?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AccountLogAuthEventsEventRisk
     */
    CompromisedCredentialsDetected?: boolean;
}
/**
 * 
 * @export
 * @interface ArtifactDownloadResponse
 */
export interface ArtifactDownloadResponse {
    /**
     * A URL to the artifact archive
     * @type {string}
     * @memberof ArtifactDownloadResponse
     */
    url?: string;
}
/**
 * 
 * @export
 * @interface ArtifactGetResponse
 */
export interface ArtifactGetResponse {
    /**
     * ID of the artifact
     * @type {string}
     * @memberof ArtifactGetResponse
     */
    artifact_id?: string;
    /**
     * Alias name of the artifact
     * @type {string}
     * @memberof ArtifactGetResponse
     */
    artifact_alias?: string;
    /**
     * Configuration of deploy automation
     * @type {boolean}
     * @memberof ArtifactGetResponse
     */
    auto_deploy?: boolean;
    /**
     * Status of contents in the artifact. [success]- All contents was published successfully. [dirty-success]- Some contents may not publish properly. [fail]- Content could not be published properly.
     * @type {string}
     * @memberof ArtifactGetResponse
     */
    context_status?: string;
    /**
     * Date which the artifact was created
     * @type {string}
     * @memberof ArtifactGetResponse
     */
    created_at?: string;
    /**
     * The user who created the artifact
     * @type {string}
     * @memberof ArtifactGetResponse
     */
    creator?: string;
    /**
     * The user who published the artifact
     * @type {string}
     * @memberof ArtifactGetResponse
     */
    deployed_by?: string;
    /**
     * Configuration of deploy automation
     * @type {boolean}
     * @memberof ArtifactGetResponse
     */
    enable_ai1wm_backup?: boolean;
    /**
     * List of URLs that was might be a failure to publish
     * @type {string}
     * @memberof ArtifactGetResponse
     */
    failure_pages?: string;
    /**
     * Date of previous deployment
     * @type {string}
     * @memberof ArtifactGetResponse
     */
    last_deployed_at?: string;
    /**
     * Date which artifact will be published
     * @type {string}
     * @memberof ArtifactGetResponse
     */
    scheduled_job_date?: string;
    /**
     * Job ID of publish schedule
     * @type {string}
     * @memberof ArtifactGetResponse
     */
    scheduled_job_id?: string;
    /**
     * Result of the scheduled publish. [succeeded]- Execution of Job was succeeded. [failed]- Execution of Job was fail.
     * @type {string}
     * @memberof ArtifactGetResponse
     */
    scheduled_job_result?: string;
    /**
     * Status of the artifact. [published-shifter]- Artifact currently published. [ready]- Artifact can publish. [error]- Artifact has something failure.
     * @type {string}
     * @memberof ArtifactGetResponse
     */
    status?: string;
}
/**
 * 
 * @export
 * @interface CdnStatusGetResponse
 */
export interface CdnStatusGetResponse {
    /**
     * Status of Shifter CDN. [Deployed]- Shifter CDN is available. [In Progress]- Shifter CDN is in invalidation.
     * @type {string}
     * @memberof CdnStatusGetResponse
     */
    status?: string;
    /**
     * Username of basic authentication (this parameter is empty when basic authentication is disabled)
     * @type {string}
     * @memberof CdnStatusGetResponse
     */
    username?: string;
    /**
     * Password of basic authentication (this parameter is empty when basic authentication is disabled)
     * @type {string}
     * @memberof CdnStatusGetResponse
     */
    password?: string;
}
/**
 * 
 * @export
 * @interface CommonErrorResponse
 */
export interface CommonErrorResponse {
    /**
     * 
     * @type {string}
     * @memberof CommonErrorResponse
     */
    message?: string;
}
/**
 * 
 * @export
 * @interface CouponGetResponse
 */
export interface CouponGetResponse {
    /**
     * 
     * @type {number}
     * @memberof CouponGetResponse
     */
    statusCode?: number;
    /**
     * 
     * @type {CouponGetResponseCoupon}
     * @memberof CouponGetResponse
     */
    coupon?: CouponGetResponseCoupon;
}
/**
 * 
 * @export
 * @interface CouponGetResponseCoupon
 */
export interface CouponGetResponseCoupon {
    /**
     * 
     * @type {string}
     * @memberof CouponGetResponseCoupon
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CouponGetResponseCoupon
     */
    object?: string;
    /**
     * 
     * @type {string}
     * @memberof CouponGetResponseCoupon
     */
    amount_off?: string;
    /**
     * 
     * @type {string}
     * @memberof CouponGetResponseCoupon
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof CouponGetResponseCoupon
     */
    currency?: string;
    /**
     * 
     * @type {string}
     * @memberof CouponGetResponseCoupon
     */
    duration?: string;
    /**
     * 
     * @type {string}
     * @memberof CouponGetResponseCoupon
     */
    duration_in_month?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CouponGetResponseCoupon
     */
    livemode?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CouponGetResponseCoupon
     */
    max_redemptions?: string;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof CouponGetResponseCoupon
     */
    metadata?: { [key: string]: object; };
    /**
     * 
     * @type {string}
     * @memberof CouponGetResponseCoupon
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof CouponGetResponseCoupon
     */
    percent_off?: string;
    /**
     * 
     * @type {string}
     * @memberof CouponGetResponseCoupon
     */
    redeem_by?: string;
    /**
     * 
     * @type {number}
     * @memberof CouponGetResponseCoupon
     */
    times_redeemed?: number;
    /**
     * 
     * @type {boolean}
     * @memberof CouponGetResponseCoupon
     */
    valid?: boolean;
}
/**
 * 
 * @export
 * @interface DomainGetResponse
 */
export interface DomainGetResponse {
    /**
     * Name of domain
     * @type {string}
     * @memberof DomainGetResponse
     */
    domain?: string;
    /**
     * Names of SANS(alternate names)
     * @type {Array<string>}
     * @memberof DomainGetResponse
     */
    subject_alternative_names?: Array<string>;
    /**
     * Status of domain. [ISSUED]- Domain can attach to the shifter site. [VALIDATION_TIMED_OUT]- Domain validation was timed it out. [EXPIRED]- Domain has been expiring.
     * @type {string}
     * @memberof DomainGetResponse
     */
    status?: string;
    /**
     * The time of when the domain was created
     * @type {string}
     * @memberof DomainGetResponse
     */
    create_time?: string;
    /**
     * A flag which indicates the domain associates with the Shifter CDN or not. [true]- Domain associates with the Shifter CDN. [false]- Domain associates another(your own) CDN.
     * @type {boolean}
     * @memberof DomainGetResponse
     */
    is_shifter_cdn?: boolean;
    /**
     * A or some reason(s) of domain validation
     * @type {string}
     * @memberof DomainGetResponse
     */
    failure_reason?: string;
    /**
     * Date of expire of the domain
     * @type {string}
     * @memberof DomainGetResponse
     */
    expired_at?: string;
    /**
     * Site information which domain associates with
     * @type {{ [key: string]: object; }}
     * @memberof DomainGetResponse
     */
    attached_project?: { [key: string]: object; };
}
/**
 * 
 * @export
 * @interface DomainValidationGetResponse
 */
export interface DomainValidationGetResponse {
    /**
     * Name of domain
     * @type {string}
     * @memberof DomainValidationGetResponse
     */
    domain?: string;
    /**
     * Names of SANS(alternate names)
     * @type {Array<string>}
     * @memberof DomainValidationGetResponse
     */
    subject_alternative_names?: Array<string>;
    /**
     * Status of domain. [ISSUED]- Domain can attach to the shifter site. [VALIDATION_TIMED_OUT]- Domain validation was timed it out. [EXPIRED]- Domain has been expiring.
     * @type {string}
     * @memberof DomainValidationGetResponse
     */
    status?: string;
    /**
     * Array of validation records of domain
     * @type {Array<DomainValidationGetResponseCnames>}
     * @memberof DomainValidationGetResponse
     */
    cnames?: Array<DomainValidationGetResponseCnames>;
    /**
     * The time of when the domain was created
     * @type {string}
     * @memberof DomainValidationGetResponse
     */
    create_time?: string;
}
/**
 * 
 * @export
 * @interface DomainValidationGetResponseCnames
 */
export interface DomainValidationGetResponseCnames {
    /**
     * Name of the record which is set as the name of the CNAME on DNS
     * @type {string}
     * @memberof DomainValidationGetResponseCnames
     */
    name?: string;
    /**
     * Value of the record which is set as the value of the CNAME on DNS
     * @type {string}
     * @memberof DomainValidationGetResponseCnames
     */
    value?: string;
}
/**
 * 
 * @export
 * @interface InlineObject
 */
export interface InlineObject {
    /**
     * email of new member
     * @type {string}
     * @memberof InlineObject
     */
    email?: string;
    /**
     * Role of new member
     * @type {string}
     * @memberof InlineObject
     */
    role?: string;
}
/**
 * 
 * @export
 * @interface InlineObject1
 */
export interface InlineObject1 {
    /**
     * Name of your site name
     * @type {string}
     * @memberof InlineObject1
     */
    site_name?: string;
    /**
     * Name of your site name(Legacy Parameter)
     * @type {string}
     * @memberof InlineObject1
     */
    project_name?: string;
    /**
     * Team Identifier which the site will be associated. when t
     * @type {string}
     * @memberof InlineObject1
     */
    team?: string;
    /**
     * Subscription ID which the site will be associated
     * @type {string}
     * @memberof InlineObject1
     */
    subscription_id?: string;
    /**
     * Plan ID which the site will be associated
     * @type {string}
     * @memberof InlineObject1
     */
    plan_id?: InlineObject1PlanIdEnum;
    /**
     * Set the directory name if you want to set another directory as root in the site
     * @type {string}
     * @memberof InlineObject1
     */
    site_subdir?: string;
    /**
     * Set to true if you want to use Shifter manged CDN for distributing media files
     * @type {boolean}
     * @memberof InlineObject1
     */
    enable_media_cdn?: boolean;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineObject1PlanIdEnum {
    Free = 'free',
    Tier01MonthYear = 'tier_01_month|year',
    Tier02MonthYear = 'tier_02_month|year',
    Tier03MonthYear = 'tier_03_month|year'
}

/**
 * 
 * @export
 * @interface InlineObject10
 */
export interface InlineObject10 {
    /**
     * This flag instructs Domain has been routed with another CDN. [true]- Domain has been associating with Shifter CDN. [false]- Domain has been associating another(your own).
     * @type {boolean}
     * @memberof InlineObject10
     */
    use_shifter_domain?: boolean;
}
/**
 * 
 * @export
 * @interface InlineObject11
 */
export interface InlineObject11 {
    /**
     * subject alternative name which is used by Shifter Generator
     * @type {string}
     * @memberof InlineObject11
     */
    san?: string;
}
/**
 * 
 * @export
 * @interface InlineObject12
 */
export interface InlineObject12 {
    /**
     * (Required) plan id
     * @type {string}
     * @memberof InlineObject12
     */
    plan_id?: InlineObject12PlanIdEnum;
    /**
     * (Not required) subscription id
     * @type {string}
     * @memberof InlineObject12
     */
    subscription_id?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineObject12PlanIdEnum {
    _01Year = 'tier_01_year',
    _01Month = 'tier_01_month',
    _02Year = 'tier_02_year',
    _02Month = 'tier_02_month',
    _03Year = 'tier_03_year',
    _03Month = 'tier_03_month'
}

/**
 * 
 * @export
 * @interface InlineObject13
 */
export interface InlineObject13 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject13
     */
    plan_id?: InlineObject13PlanIdEnum;
    /**
     * 
     * @type {string}
     * @memberof InlineObject13
     */
    current_pan_id?: InlineObject13CurrentPanIdEnum;
    /**
     * 
     * @type {string}
     * @memberof InlineObject13
     */
    site_id?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum InlineObject13PlanIdEnum {
    _01Year = 'tier_01_year',
    _01Month = 'tier_01_month',
    _02Year = 'tier_02_year',
    _02Month = 'tier_02_month',
    _03Year = 'tier_03_year',
    _03Month = 'tier_03_month'
}
/**
    * @export
    * @enum {string}
    */
export enum InlineObject13CurrentPanIdEnum {
    _01Year = 'tier_01_year',
    _01Month = 'tier_01_month',
    _02Year = 'tier_02_year',
    _02Month = 'tier_02_month',
    _03Year = 'tier_03_year',
    _03Month = 'tier_03_month'
}

/**
 * 
 * @export
 * @interface InlineObject14
 */
export interface InlineObject14 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject14
     */
    card_exp_month?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject14
     */
    card_exp_year?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject14
     */
    card_last4?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject14
     */
    card_id?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject14
     */
    card_token?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject14
     */
    card_brand?: string;
}
/**
 * 
 * @export
 * @interface InlineObject15
 */
export interface InlineObject15 {
    /**
     * 
     * @type {Array<string>}
     * @memberof InlineObject15
     */
    sites?: Array<string>;
}
/**
 * 
 * @export
 * @interface InlineObject16
 */
export interface InlineObject16 {
    /**
     * 
     * @type {Array<string>}
     * @memberof InlineObject16
     */
    sites?: Array<string>;
}
/**
 * 
 * @export
 * @interface InlineObject17
 */
export interface InlineObject17 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject17
     */
    role_name?: string;
}
/**
 * 
 * @export
 * @interface InlineObject18
 */
export interface InlineObject18 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject18
     */
    role_name?: string;
}
/**
 * 
 * @export
 * @interface InlineObject19
 */
export interface InlineObject19 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject19
     */
    hook_event?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject19
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject19
     */
    method?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject19
     */
    enabled?: string;
    /**
     * 
     * @type {object}
     * @memberof InlineObject19
     */
    headers?: object;
}
/**
 * 
 * @export
 * @interface InlineObject2
 */
export interface InlineObject2 {
    /**
     * Name of the site
     * @type {string}
     * @memberof InlineObject2
     */
    site_name?: string;
    /**
     * All in one WP migration configuration. [true]- Enable making backup file(.wpress)
     * @type {boolean}
     * @memberof InlineObject2
     */
    enable_ai1wm_backup?: boolean;
    /**
     * Shifter media CDN configuration. [true]- Enable Media CDN.
     * @type {boolean}
     * @memberof InlineObject2
     */
    enable_media_cdn?: boolean;
    /**
     * Automatic publishing configuration. [true]- Enable automatic publish. Latest artifact will be published automatically when the creating artifact was finished.
     * @type {boolean}
     * @memberof InlineObject2
     */
    automation?: boolean;
}
/**
 * 
 * @export
 * @interface InlineObject20
 */
export interface InlineObject20 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject20
     */
    hook_event?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject20
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject20
     */
    method?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject20
     */
    enabled?: string;
    /**
     * 
     * @type {object}
     * @memberof InlineObject20
     */
    headers?: object;
}
/**
 * 
 * @export
 * @interface InlineObject21
 */
export interface InlineObject21 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject21
     */
    hook_event?: string;
}
/**
 * 
 * @export
 * @interface InlineObject22
 */
export interface InlineObject22 {
    /**
     * date of publish
     * @type {string}
     * @memberof InlineObject22
     */
    date?: string;
}
/**
 * 
 * @export
 * @interface InlineObject23
 */
export interface InlineObject23 {
    /**
     * new date of publish
     * @type {string}
     * @memberof InlineObject23
     */
    date?: string;
}
/**
 * 
 * @export
 * @interface InlineObject24
 */
export interface InlineObject24 {
    /**
     * Artifact name
     * @type {string}
     * @memberof InlineObject24
     */
    artifact_name?: string;
}
/**
 * 
 * @export
 * @interface InlineObject25
 */
export interface InlineObject25 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject25
     */
    event_type?: string;
}
/**
 * 
 * @export
 * @interface InlineObject26
 */
export interface InlineObject26 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject26
     */
    email?: string;
}
/**
 * 
 * @export
 * @interface InlineObject27
 */
export interface InlineObject27 {
    /**
     * New city name which will be written in invoice
     * @type {string}
     * @memberof InlineObject27
     */
    city?: string;
    /**
     * New country name which will be written in invoice
     * @type {string}
     * @memberof InlineObject27
     */
    country?: string;
    /**
     * New postal(zip) code name which will be written in invoice
     * @type {string}
     * @memberof InlineObject27
     */
    postal_code?: string;
    /**
     * New state name which will be written in invoice
     * @type {string}
     * @memberof InlineObject27
     */
    state?: string;
    /**
     * Additional information if you needed, ex) street name, house number etc..
     * @type {string}
     * @memberof InlineObject27
     */
    line1?: string;
    /**
     * Additional information if you needed, ex) street name, house number etc..
     * @type {string}
     * @memberof InlineObject27
     */
    line2?: string;
}
/**
 * 
 * @export
 * @interface InlineObject28
 */
export interface InlineObject28 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject28
     */
    subject_alternative_name?: string;
}
/**
 * 
 * @export
 * @interface InlineObject29
 */
export interface InlineObject29 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject29
     */
    site_id?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineObject29
     */
    san?: string;
}
/**
 * 
 * @export
 * @interface InlineObject3
 */
export interface InlineObject3 {
    /**
     * Site name
     * @type {string}
     * @memberof InlineObject3
     */
    site_name?: string;
}
/**
 * 
 * @export
 * @interface InlineObject30
 */
export interface InlineObject30 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject30
     */
    site_id?: string;
    /**
     * 
     * @type {boolean}
     * @memberof InlineObject30
     */
    use_shifter_domain?: boolean;
}
/**
 * 
 * @export
 * @interface InlineObject31
 */
export interface InlineObject31 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject31
     */
    subject_alternative_name?: string;
}
/**
 * 
 * @export
 * @interface InlineObject32
 */
export interface InlineObject32 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject32
     */
    subject_alternative_name?: string;
}
/**
 * 
 * @export
 * @interface InlineObject4
 */
export interface InlineObject4 {
    /**
     * Start WordPress as emergency user default is false
     * @type {boolean}
     * @memberof InlineObject4
     */
    emergency?: boolean;
}
/**
 * 
 * @export
 * @interface InlineObject5
 */
export interface InlineObject5 {
    /**
     * 
     * @type {string}
     * @memberof InlineObject5
     */
    dir_name?: string;
}
/**
 * 
 * @export
 * @interface InlineObject6
 */
export interface InlineObject6 {
    /**
     * s3 bucket name to transfer access log
     * @type {string}
     * @memberof InlineObject6
     */
    bucket_name?: string;
    /**
     * domain which bucket is placed on
     * @type {string}
     * @memberof InlineObject6
     */
    domain?: string;
}
/**
 * 
 * @export
 * @interface InlineObject7
 */
export interface InlineObject7 {
    /**
     * filter by status. [valid_only]- list only domains that validation succeeded. [valid_and_expired]- list domains that status is valid or expired.
     * @type {string}
     * @memberof InlineObject7
     */
    filter?: string;
}
/**
 * 
 * @export
 * @interface InlineObject8
 */
export interface InlineObject8 {
    /**
     * Array of SANS(alternate names)
     * @type {string}
     * @memberof InlineObject8
     */
    subject_alternative_name?: string;
}
/**
 * 
 * @export
 * @interface InlineObject9
 */
export interface InlineObject9 {
    /**
     * Flag the domain associates with Shifter CDN. [true]- Domain associates with Shifter CDN. [false]- Domain is only marked as \'attached\'. Route domain to shifter site by themselves.
     * @type {boolean}
     * @memberof InlineObject9
     */
    use_shifter_domain?: boolean;
}
/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * 
     * @type {Array<InlineResponse200Errors>}
     * @memberof InlineResponse200
     */
    errors?: Array<InlineResponse200Errors>;
}
/**
 * 
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     * 
     * @type {Array<TeamsResponseWithId>}
     * @memberof InlineResponse2001
     */
    owner?: Array<TeamsResponseWithId>;
    /**
     * 
     * @type {Array<TeamsResponseWithId>}
     * @memberof InlineResponse2001
     */
    member?: Array<TeamsResponseWithId>;
}
/**
 * 
 * @export
 * @interface InlineResponse20010
 */
export interface InlineResponse20010 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20010
     */
    create_time?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20010
     */
    update_time?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20010
     */
    progress?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20010
     */
    message?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20011
 */
export interface InlineResponse20011 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20011
     */
    transfer_gb?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20011
     */
    track_month?: number;
}
/**
 * 
 * @export
 * @interface InlineResponse20012
 */
export interface InlineResponse20012 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20012
     */
    EventId?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20012
     */
    EventType?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20012
     */
    CreationDate?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20012
     */
    EventResponse?: string;
    /**
     * 
     * @type {AccountLogAuthEventsEventRisk}
     * @memberof InlineResponse20012
     */
    EventRisk?: AccountLogAuthEventsEventRisk;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20012
     */
    ChallengeResponses?: string;
    /**
     * 
     * @type {AccountLogAuthEventsEventContextData}
     * @memberof InlineResponse20012
     */
    EventContextData?: AccountLogAuthEventsEventContextData;
    /**
     * 
     * @type {AccountLogAuthEventsEventFeedback}
     * @memberof InlineResponse20012
     */
    EventFeedback?: AccountLogAuthEventsEventFeedback;
}
/**
 * 
 * @export
 * @interface InlineResponse20013
 */
export interface InlineResponse20013 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20013
     */
    domain?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof InlineResponse20013
     */
    subject_alternative_names?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20013
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20013
     */
    create_time?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof InlineResponse20013
     */
    validation_emails?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse20013
     */
    is_shifter_cdn?: boolean;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20013
     */
    failure_reason?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20013
     */
    expired_at?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2002
 */
export interface InlineResponse2002 {
    /**
     * 
     * @type {Array<TeamsResponseWithId>}
     * @memberof InlineResponse2002
     */
    owner?: Array<TeamsResponseWithId>;
    /**
     * 
     * @type {Array<TeamsResponseWithId>}
     * @memberof InlineResponse2002
     */
    member?: Array<TeamsResponseWithId>;
    /**
     * If user belongs to only one team, Warning message
     * @type {string}
     * @memberof InlineResponse2002
     */
    message?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2003
 */
export interface InlineResponse2003 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2003
     */
    username?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2003
     */
    email?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2004
 */
export interface InlineResponse2004 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2004
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2004
     */
    team_id?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2004
     */
    user_status?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2004
     */
    email?: string;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2004
     */
    enable_mfa?: boolean;
}
/**
 * 
 * @export
 * @interface InlineResponse2005
 */
export interface InlineResponse2005 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2005
     */
    role_name?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2006
 */
export interface InlineResponse2006 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006
     */
    site_id?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006
     */
    hook_event?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006
     */
    webhook_url?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006
     */
    method?: string;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2006
     */
    enabled?: boolean;
    /**
     * 
     * @type {object}
     * @memberof InlineResponse2006
     */
    headers?: object;
}
/**
 * 
 * @export
 * @interface InlineResponse2007
 */
export interface InlineResponse2007 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2007
     */
    site_id?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2007
     */
    hook_event?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2007
     */
    webhook_url?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2007
     */
    result?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2007
     */
    jon_id?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2007
     */
    called_date?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2007
     */
    text?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2008
 */
export interface InlineResponse2008 {
    /**
     * URL of backup
     * @type {string}
     * @memberof InlineResponse2008
     */
    url?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2009
 */
export interface InlineResponse2009 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2009
     */
    role?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse200Errors
 */
export interface InlineResponse200Errors {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200Errors
     */
    timestamp?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200Errors
     */
    error_level?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200Errors
     */
    message?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse201
 */
export interface InlineResponse201 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse201
     */
    notification_id?: string;
    /**
     * The password of emergency user. This password is only returned during emergency requests.
     * @type {string}
     * @memberof InlineResponse201
     */
    emergency_password?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2011
 */
export interface InlineResponse2011 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2011
     */
    notification_id?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2012
 */
export interface InlineResponse2012 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2012
     */
    team_id?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2013
 */
export interface InlineResponse2013 {
    /**
     * Job Id which publish the artifact on specific date. This parameter only returns when the date of publish was specified.
     * @type {string}
     * @memberof InlineResponse2013
     */
    job_id?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2014
 */
export interface InlineResponse2014 {
    /**
     * Job Id if date parameter specified
     * @type {string}
     * @memberof InlineResponse2014
     */
    job_id?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2015
 */
export interface InlineResponse2015 {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2015
     */
    status?: boolean;
}
/**
 * 
 * @export
 * @interface LoginErrorResponse
 */
export interface LoginErrorResponse {
    /**
     * Invalid Username or Password
     * @type {string}
     * @memberof LoginErrorResponse
     */
    message?: string;
}
/**
 * 
 * @export
 * @interface LoginPostRequest
 */
export interface LoginPostRequest {
    /**
     * shifter account name
     * @type {string}
     * @memberof LoginPostRequest
     */
    username?: string;
    /**
     * password
     * @type {string}
     * @memberof LoginPostRequest
     */
    password?: string;
}
/**
 * 
 * @export
 * @interface LoginPostResponse
 */
export interface LoginPostResponse {
    /**
     * Access Token for Shifter API. This token will be expired in 1 hour.
     * @type {string}
     * @memberof LoginPostResponse
     */
    AccessToken?: string;
    /**
     * Refresh Token for Shifter API. This token will be expired in 7 days.
     * @type {string}
     * @memberof LoginPostResponse
     */
    RefreshToken?: string;
}
/**
 * 
 * @export
 * @interface PlanGetResponse
 */
export interface PlanGetResponse {
    /**
     * ID of the plan
     * @type {string}
     * @memberof PlanGetResponse
     */
    id?: string;
    /**
     * Name of the plan
     * @type {string}
     * @memberof PlanGetResponse
     */
    nickname?: string;
    /**
     * Term of the plan. [monthly or annual]
     * @type {string}
     * @memberof PlanGetResponse
     */
    interval?: string;
    /**
     * Product name which the plan is associated with
     * @type {string}
     * @memberof PlanGetResponse
     */
    product?: string;
    /**
     * Amount of the plan
     * @type {string}
     * @memberof PlanGetResponse
     */
    amount?: string;
    /**
     * Currency of the plan.
     * @type {string}
     * @memberof PlanGetResponse
     */
    currency?: string;
    /**
     * 
     * @type {PlanGetResponseMetadata}
     * @memberof PlanGetResponse
     */
    metadata?: PlanGetResponseMetadata;
}
/**
 * Metadata of the plan
 * @export
 * @interface PlanGetResponseMetadata
 */
export interface PlanGetResponseMetadata {
    /**
     * Maximum number of sites that plan can accept.
     * @type {string}
     * @memberof PlanGetResponseMetadata
     */
    projects_limit?: string;
    /**
     * Maximum artifacts that plan can leave
     * @type {string}
     * @memberof PlanGetResponseMetadata
     */
    artifact_limit?: string;
    /**
     * Whether exporting artifacts is available or not.
     * @type {boolean}
     * @memberof PlanGetResponseMetadata
     */
    export_artifact?: boolean;
    /**
     * Limit of maximum storage.
     * @type {string}
     * @memberof PlanGetResponseMetadata
     */
    max_disk_gb?: string;
    /**
     * Limit of maximum data transfer quota.
     * @type {string}
     * @memberof PlanGetResponseMetadata
     */
    max_transfer_gb?: string;
    /**
     * (deprecated) Whether SubUser feature is available or not.
     * @type {boolean}
     * @memberof PlanGetResponseMetadata
     */
    enable_subuser?: boolean;
    /**
     * Whether domain feature is available or not
     * @type {boolean}
     * @memberof PlanGetResponseMetadata
     */
    domain_setting?: boolean;
    /**
     * Whether notification feature is available or not
     * @type {boolean}
     * @memberof PlanGetResponseMetadata
     */
    email_notification?: boolean;
    /**
     * Whether notification feature is available or not
     * @type {boolean}
     * @memberof PlanGetResponseMetadata
     */
    slack_notification?: boolean;
    /**
     * Whether outgoing webhook feature is available or not
     * @type {boolean}
     * @memberof PlanGetResponseMetadata
     */
    enable_webhook?: boolean;
    /**
     * Whether exporting CDN access log feature is available or not
     * @type {boolean}
     * @memberof PlanGetResponseMetadata
     */
    export_access_log?: boolean;
    /**
     * Whether media CDN feature is available or not
     * @type {boolean}
     * @memberof PlanGetResponseMetadata
     */
    media_cdn?: boolean;
    /**
     * Whether basic authentication feature is available or not
     * @type {boolean}
     * @memberof PlanGetResponseMetadata
     */
    basic_auth?: boolean;
    /**
     * Whether backup automation feature is available or not
     * @type {boolean}
     * @memberof PlanGetResponseMetadata
     */
    auto_backup?: boolean;
    /**
     * Whether WordPress event webhook feature is available or not
     * @type {boolean}
     * @memberof PlanGetResponseMetadata
     */
    webhook_wp_launch?: boolean;
    /**
     * Whether exporting WordPress backup feature is available or not
     * @type {boolean}
     * @memberof PlanGetResponseMetadata
     */
    export_backup?: boolean;
    /**
     * Maximum API (directly) call quota.
     * @type {number}
     * @memberof PlanGetResponseMetadata
     */
    max_wp_start_request_day?: number;
}
/**
 * 
 * @export
 * @interface PlanResponse
 */
export interface PlanResponse {
    /**
     * 
     * @type {string}
     * @memberof PlanResponse
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof PlanResponse
     */
    object?: string;
    /**
     * 
     * @type {number}
     * @memberof PlanResponse
     */
    amount?: number;
    /**
     * 
     * @type {string}
     * @memberof PlanResponse
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof PlanResponse
     */
    currency?: string;
    /**
     * 
     * @type {string}
     * @memberof PlanResponse
     */
    interval?: string;
    /**
     * 
     * @type {number}
     * @memberof PlanResponse
     */
    interval_count?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PlanResponse
     */
    livemode?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PlanResponse
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof PlanResponse
     */
    trial_period_days?: number;
    /**
     * 
     * @type {PlanResponseMetadata}
     * @memberof PlanResponse
     */
    metadata?: PlanResponseMetadata;
}
/**
 * 
 * @export
 * @interface PlanResponseMetadata
 */
export interface PlanResponseMetadata {
    /**
     * 
     * @type {string}
     * @memberof PlanResponseMetadata
     */
    sites_limit?: string;
    /**
     * 
     * @type {string}
     * @memberof PlanResponseMetadata
     */
    domain_setting?: string;
    /**
     * 
     * @type {string}
     * @memberof PlanResponseMetadata
     */
    user_limit?: string;
    /**
     * 
     * @type {string}
     * @memberof PlanResponseMetadata
     */
    import_archives?: string;
    /**
     * 
     * @type {string}
     * @memberof PlanResponseMetadata
     */
    export_archives?: string;
    /**
     * 
     * @type {string}
     * @memberof PlanResponseMetadata
     */
    backup?: string;
    /**
     * 
     * @type {string}
     * @memberof PlanResponseMetadata
     */
    max_transfer_gb?: string;
    /**
     * 
     * @type {string}
     * @memberof PlanResponseMetadata
     */
    max_disk_gb?: string;
    /**
     * 
     * @type {string}
     * @memberof PlanResponseMetadata
     */
    enable_subuser?: string;
}
/**
 * 
 * @export
 * @interface PreviousPlanResponse
 */
export interface PreviousPlanResponse {
    /**
     * 
     * @type {string}
     * @memberof PreviousPlanResponse
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof PreviousPlanResponse
     */
    object?: string;
    /**
     * 
     * @type {number}
     * @memberof PreviousPlanResponse
     */
    amount?: number;
    /**
     * 
     * @type {string}
     * @memberof PreviousPlanResponse
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof PreviousPlanResponse
     */
    currency?: string;
    /**
     * 
     * @type {string}
     * @memberof PreviousPlanResponse
     */
    interval?: string;
    /**
     * 
     * @type {number}
     * @memberof PreviousPlanResponse
     */
    interval_count?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PreviousPlanResponse
     */
    livemode?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PreviousPlanResponse
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof PreviousPlanResponse
     */
    trial_period_days?: number;
    /**
     * 
     * @type {number}
     * @memberof PreviousPlanResponse
     */
    annualprice?: number;
    /**
     * 
     * @type {PlanResponseMetadata}
     * @memberof PreviousPlanResponse
     */
    metadata?: PlanResponseMetadata;
}
/**
 * 
 * @export
 * @interface RoleGetResponse
 */
export interface RoleGetResponse {
    /**
     * Name of the role
     * @type {string}
     * @memberof RoleGetResponse
     */
    name?: string;
    /**
     * if this value is true, the role has been deprecated.
     * @type {boolean}
     * @memberof RoleGetResponse
     */
    deprecated?: boolean;
    /**
     * description of the role
     * @type {string}
     * @memberof RoleGetResponse
     */
    description?: string;
    /**
     * Access policies that associated with the role
     * @type {Array<string>}
     * @memberof RoleGetResponse
     */
    policies?: Array<string>;
}
/**
 * 
 * @export
 * @interface SiteCreateResponse
 */
export interface SiteCreateResponse {
    /**
     * ID of the site
     * @type {string}
     * @memberof SiteCreateResponse
     */
    project_id?: string;
    /**
     * Name of the site
     * @type {string}
     * @memberof SiteCreateResponse
     */
    project_name?: string;
    /**
     * CDN url of the Site
     * @type {string}
     * @memberof SiteCreateResponse
     */
    shifter_cdn_url?: string;
    /**
     * Subscription ID which was associated to the site
     * @type {string}
     * @memberof SiteCreateResponse
     */
    subscription_id?: string;
    /**
     * Plan ID which was associated to the site
     * @type {string}
     * @memberof SiteCreateResponse
     */
    plan_id?: string;
    /**
     * Team ID which was associated to the site
     * @type {string}
     * @memberof SiteCreateResponse
     */
    team_id?: string;
}
/**
 * 
 * @export
 * @interface SiteResponse
 */
export interface SiteResponse {
    /**
     * ID of the site
     * @type {string}
     * @memberof SiteResponse
     */
    project_id?: string;
    /**
     * 
     * @type {string}
     * @memberof SiteResponse
     */
    site_id?: string;
    /**
     * Name of the site
     * @type {string}
     * @memberof SiteResponse
     */
    project_name?: string;
    /**
     * 
     * @type {string}
     * @memberof SiteResponse
     */
    site_name?: string;
    /**
     * Status of the site. [inuse] - This status indicates WordPress is not running, [inservice] - This status indicates WordPress is running(User or team member are currently editing something)
     * @type {string}
     * @memberof SiteResponse
     */
    stock_state?: string;
    /**
     * Owner of the site
     * @type {string}
     * @memberof SiteResponse
     */
    project_owner?: string;
    /**
     * 
     * @type {string}
     * @memberof SiteResponse
     */
    site_owner?: string;
    /**
     * The url of WordPress which is currently running. This value is set empty when WordPress is not running.
     * @type {string}
     * @memberof SiteResponse
     */
    wordpress_site_url?: string;
    /**
     * Custom domain which was associated to the site. This value is set empty when no custom domain was associated.
     * @type {string}
     * @memberof SiteResponse
     */
    domain?: string;
    /**
     * PHP version which WordPress uses. This parameter is set the latest version by the system.
     * @type {string}
     * @memberof SiteResponse
     */
    php_version?: string;
    /**
     * Public URL of the site. This URL is provides the system. User can not change.
     * @type {string}
     * @memberof SiteResponse
     */
    access_url?: string;
    /**
     * The time which site has been updated
     * @type {string}
     * @memberof SiteResponse
     */
    update_time?: string;
    /**
     * 
     * @type {string}
     * @memberof SiteResponse
     */
    last_launched?: string;
    /**
     * Public URL of the site. This URL is provides the system. User can not change.
     * @type {number}
     * @memberof SiteResponse
     */
    disk_usage?: number;
    /**
     * The way of publish. Only \"shifter_cdn\"
     * @type {string}
     * @memberof SiteResponse
     */
    deploy_type?: string;
    /**
     * Original AWS CloudFront URL.
     * @type {string}
     * @memberof SiteResponse
     */
    raw_url?: string;
    /**
     * Date which the site created
     * @type {string}
     * @memberof SiteResponse
     */
    create_time?: string;
    /**
     * Whether automatic deployment is enable or not
     * @type {boolean}
     * @memberof SiteResponse
     */
    automation?: boolean;
    /**
     * Status of generating process. [ingenerate]- publishing (Generate static site) is currently running. [inuse]- Publishing is currently not running.
     * @type {string}
     * @memberof SiteResponse
     */
    generate_state?: string;
    /**
     * Unix Epoch(seconds) which indicates trial will be expired. This property only provides when the site is in trial.
     * @type {number}
     * @memberof SiteResponse
     */
    trial?: number;
    /**
     * Subscription ID which the site associates with
     * @type {string}
     * @memberof SiteResponse
     */
    subscription_id?: string;
    /**
     * Plan ID which the site associates with
     * @type {string}
     * @memberof SiteResponse
     */
    plan_id?: string;
    /**
     * (deprecated) Team ID which the site belongs to
     * @type {string}
     * @memberof SiteResponse
     */
    org_id?: string;
    /**
     * Team ID which the site belongs to
     * @type {string}
     * @memberof SiteResponse
     */
    team_id?: string;
    /**
     * Whether All in one WP migration feature is currently enable or not
     * @type {boolean}
     * @memberof SiteResponse
     */
    enable_ai1wm_backup?: boolean;
    /**
     * Whether media_cdn feature is currently enable or not
     * @type {boolean}
     * @memberof SiteResponse
     */
    enable_media_cdn?: boolean;
    /**
     * The key of media cdn of the site
     * @type {string}
     * @memberof SiteResponse
     */
    media_cdn_key?: string;
    /**
     * Whether basic authentication feature is currently enable or not
     * @type {boolean}
     * @memberof SiteResponse
     */
    basic_auth?: boolean;
    /**
     * Alternate domain which the site will be publish as this domain.
     * @type {string}
     * @memberof SiteResponse
     */
    selected_domain?: string;
    /**
     * Root directory in the WordPress.
     * @type {string}
     * @memberof SiteResponse
     */
    subdir_name?: string;
    /**
     * URL which Access Log of Shifter CDN will be stored.
     * @type {string}
     * @memberof SiteResponse
     */
    access_log_path?: string;
    /**
     * Whether site delete protection feature is currently enable or not
     * @type {boolean}
     * @memberof SiteResponse
     */
    delete_protection?: boolean;
    /**
     * Date which previous PHP error in WordPress occurred.
     * @type {string}
     * @memberof SiteResponse
     */
    last_error_occurrence_date?: string;
    /**
     * Whether Pay As You Go of Data transfer feature is currently enable or not
     * @type {boolean}
     * @memberof SiteResponse
     */
    enable_cdn_autocharge?: boolean;
}
/**
 * 
 * @export
 * @interface StatusGetResponse
 */
export interface StatusGetResponse {
    /**
     * 
     * @type {StatusGetResponseMaintenance}
     * @memberof StatusGetResponse
     */
    maintenance?: StatusGetResponseMaintenance;
    /**
     * 
     * @type {StatusGetResponseUser}
     * @memberof StatusGetResponse
     */
    user?: StatusGetResponseUser;
}
/**
 * 
 * @export
 * @interface StatusGetResponseMaintenance
 */
export interface StatusGetResponseMaintenance {
    /**
     * Description of status of current Shifter system
     * @type {string}
     * @memberof StatusGetResponseMaintenance
     */
    message?: string;
    /**
     * Target components of maintenance.
     * @type {Array<string>}
     * @memberof StatusGetResponseMaintenance
     */
    target?: Array<string>;
    /**
     * Current system status. [not_maintenance]- Shifter is not in maintenance. [now_maintenance]- Shifter is currently in maintenance. [pre_maintenance]- Shifter will be into maintenance soon.
     * @type {string}
     * @memberof StatusGetResponseMaintenance
     */
    status?: string;
}
/**
 * Account status. This properties only reflect for Legacy Plan.
 * @export
 * @interface StatusGetResponseUser
 */
export interface StatusGetResponseUser {
    /**
     * Payment method status of the account. [Registered]- Account has payment method. [unRegistered]- Account does not register payment method yet.
     * @type {string}
     * @memberof StatusGetResponseUser
     */
    credit_card_status?: string;
    /**
     * Maximum number of the sites
     * @type {number}
     * @memberof StatusGetResponseUser
     */
    upper_limit_projects?: number;
    /**
     * Limit of maximum storage.
     * @type {number}
     * @memberof StatusGetResponseUser
     */
    max_transfer_gb?: number;
    /**
     * Limit of maximum data transfer quota
     * @type {number}
     * @memberof StatusGetResponseUser
     */
    max_disk_gb?: number;
    /**
     * Whether domain feature is available or not
     * @type {string}
     * @memberof StatusGetResponseUser
     */
    domain_setting?: string;
    /**
     * (deprecated)
     * @type {string}
     * @memberof StatusGetResponseUser
     */
    import_archives?: string;
    /**
     * (deprecated)
     * @type {string}
     * @memberof StatusGetResponseUser
     */
    export_archives?: string;
    /**
     * 
     * @type {number}
     * @memberof StatusGetResponseUser
     */
    backup?: number;
    /**
     * (deprecated)
     * @type {string}
     * @memberof StatusGetResponseUser
     */
    enable_subuser?: string;
    /**
     * 
     * @type {StatusGetResponseUserNotification}
     * @memberof StatusGetResponseUser
     */
    notification?: StatusGetResponseUserNotification;
    /**
     * ID of the current plan. (only Legacy plan)
     * @type {string}
     * @memberof StatusGetResponseUser
     */
    plan_id?: string;
    /**
     * 
     * @type {StatusGetResponseUserGroup}
     * @memberof StatusGetResponseUser
     */
    group?: StatusGetResponseUserGroup;
}
/**
 * (deprecated)
 * @export
 * @interface StatusGetResponseUserGroup
 */
export interface StatusGetResponseUserGroup {
    /**
     * Name of the group.
     * @type {string}
     * @memberof StatusGetResponseUserGroup
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface StatusGetResponseUserNotification
 */
export interface StatusGetResponseUserNotification {
    /**
     * 
     * @type {StatusGetResponseUserNotificationEmail}
     * @memberof StatusGetResponseUserNotification
     */
    email?: StatusGetResponseUserNotificationEmail;
}
/**
 * 
 * @export
 * @interface StatusGetResponseUserNotificationEmail
 */
export interface StatusGetResponseUserNotificationEmail {
    /**
     * 
     * @type {string}
     * @memberof StatusGetResponseUserNotificationEmail
     */
    destination?: string;
}
/**
 * 
 * @export
 * @interface SubscriptionCreateResponse
 */
export interface SubscriptionCreateResponse {
    /**
     * Subscription ID
     * @type {string}
     * @memberof SubscriptionCreateResponse
     */
    id?: string;
}
/**
 * 
 * @export
 * @interface SubscriptionGetResponse
 */
export interface SubscriptionGetResponse {
    /**
     * 
     * @type {string}
     * @memberof SubscriptionGetResponse
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionGetResponse
     */
    object?: string;
    /**
     * 
     * @type {number}
     * @memberof SubscriptionGetResponse
     */
    application_fee_percent?: number;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionGetResponse
     */
    billing?: string;
    /**
     * 
     * @type {number}
     * @memberof SubscriptionGetResponse
     */
    billing_cycle_anchor?: number;
    /**
     * 
     * @type {SubscriptionGetResponseBillingThresholds}
     * @memberof SubscriptionGetResponse
     */
    billing_thresholds?: SubscriptionGetResponseBillingThresholds;
    /**
     * 
     * @type {number}
     * @memberof SubscriptionGetResponse
     */
    cancel_at?: number;
    /**
     * 
     * @type {number}
     * @memberof SubscriptionGetResponse
     */
    cancel_at_period_end?: number;
    /**
     * 
     * @type {number}
     * @memberof SubscriptionGetResponse
     */
    canceled_at?: number;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionGetResponse
     */
    collection_method?: string;
    /**
     * 
     * @type {number}
     * @memberof SubscriptionGetResponse
     */
    created?: number;
    /**
     * 
     * @type {number}
     * @memberof SubscriptionGetResponse
     */
    current_period_end?: number;
    /**
     * 
     * @type {number}
     * @memberof SubscriptionGetResponse
     */
    current_period_start?: number;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionGetResponse
     */
    customer?: string;
    /**
     * 
     * @type {number}
     * @memberof SubscriptionGetResponse
     */
    days_until_due?: number;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionGetResponse
     */
    default_payment_method?: string;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionGetResponse
     */
    default_source?: string;
    /**
     * 
     * @type {Array<SubscriptionGetResponseDefaultTaxRates>}
     * @memberof SubscriptionGetResponse
     */
    default_tax_rates?: Array<SubscriptionGetResponseDefaultTaxRates>;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof SubscriptionGetResponse
     */
    discount?: { [key: string]: object; };
    /**
     * 
     * @type {number}
     * @memberof SubscriptionGetResponse
     */
    ended_at?: number;
    /**
     * 
     * @type {SubscriptionGetResponseInvoiceCustomerBalanceSettings}
     * @memberof SubscriptionGetResponse
     */
    invoice_customer_balance_settings?: SubscriptionGetResponseInvoiceCustomerBalanceSettings;
    /**
     * 
     * @type {SubscriptionGetResponseItems}
     * @memberof SubscriptionGetResponse
     */
    items?: SubscriptionGetResponseItems;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionGetResponse
     */
    latest_invoice?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SubscriptionGetResponse
     */
    livemode?: boolean;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof SubscriptionGetResponse
     */
    metadata?: { [key: string]: object; };
    /**
     * 
     * @type {number}
     * @memberof SubscriptionGetResponse
     */
    next_pending_invoice_item_invoice?: number;
    /**
     * 
     * @type {SubscriptionGetResponsePauseCollection}
     * @memberof SubscriptionGetResponse
     */
    pause_collection?: SubscriptionGetResponsePauseCollection;
    /**
     * 
     * @type {SubscriptionGetResponsePendingInvoiceItemInterval}
     * @memberof SubscriptionGetResponse
     */
    pending_invoice_item_interval?: SubscriptionGetResponsePendingInvoiceItemInterval;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionGetResponse
     */
    pending_setup_intent?: string;
    /**
     * 
     * @type {SubscriptionGetResponsePendingUpdate}
     * @memberof SubscriptionGetResponse
     */
    pending_update?: SubscriptionGetResponsePendingUpdate;
    /**
     * Form of data is the same as the data.Items
     * @type {{ [key: string]: object; }}
     * @memberof SubscriptionGetResponse
     */
    plan?: { [key: string]: object; };
    /**
     * 
     * @type {number}
     * @memberof SubscriptionGetResponse
     */
    quantity?: number;
    /**
     * 
     * @type {number}
     * @memberof SubscriptionGetResponse
     */
    schedule?: number;
    /**
     * 
     * @type {number}
     * @memberof SubscriptionGetResponse
     */
    start?: number;
    /**
     * 
     * @type {number}
     * @memberof SubscriptionGetResponse
     */
    start_date?: number;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionGetResponse
     */
    status?: string;
    /**
     * 
     * @type {number}
     * @memberof SubscriptionGetResponse
     */
    tax_percent?: number;
    /**
     * 
     * @type {SubscriptionGetResponseTransferData}
     * @memberof SubscriptionGetResponse
     */
    transfer_data?: SubscriptionGetResponseTransferData;
    /**
     * 
     * @type {number}
     * @memberof SubscriptionGetResponse
     */
    trial_end?: number;
    /**
     * 
     * @type {number}
     * @memberof SubscriptionGetResponse
     */
    trial_start?: number;
}
/**
 * 
 * @export
 * @interface SubscriptionGetResponseBillingThresholds
 */
export interface SubscriptionGetResponseBillingThresholds {
    /**
     * 
     * @type {number}
     * @memberof SubscriptionGetResponseBillingThresholds
     */
    amount_gte?: number;
    /**
     * 
     * @type {boolean}
     * @memberof SubscriptionGetResponseBillingThresholds
     */
    reset_billing_cycle_anchor?: boolean;
}
/**
 * 
 * @export
 * @interface SubscriptionGetResponseDefaultTaxRates
 */
export interface SubscriptionGetResponseDefaultTaxRates {
    /**
     * 
     * @type {string}
     * @memberof SubscriptionGetResponseDefaultTaxRates
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionGetResponseDefaultTaxRates
     */
    object?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SubscriptionGetResponseDefaultTaxRates
     */
    active?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionGetResponseDefaultTaxRates
     */
    country?: string;
    /**
     * 
     * @type {number}
     * @memberof SubscriptionGetResponseDefaultTaxRates
     */
    created?: number;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionGetResponseDefaultTaxRates
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionGetResponseDefaultTaxRates
     */
    display_name?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SubscriptionGetResponseDefaultTaxRates
     */
    inclusive?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionGetResponseDefaultTaxRates
     */
    jurisdiction?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SubscriptionGetResponseDefaultTaxRates
     */
    livemode?: boolean;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof SubscriptionGetResponseDefaultTaxRates
     */
    metadata?: { [key: string]: object; };
    /**
     * 
     * @type {number}
     * @memberof SubscriptionGetResponseDefaultTaxRates
     */
    percentage?: number;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionGetResponseDefaultTaxRates
     */
    state?: string;
}
/**
 * 
 * @export
 * @interface SubscriptionGetResponseInvoiceCustomerBalanceSettings
 */
export interface SubscriptionGetResponseInvoiceCustomerBalanceSettings {
    /**
     * 
     * @type {boolean}
     * @memberof SubscriptionGetResponseInvoiceCustomerBalanceSettings
     */
    consume_applied_balance_on_void?: boolean;
}
/**
 * 
 * @export
 * @interface SubscriptionGetResponseItems
 */
export interface SubscriptionGetResponseItems {
    /**
     * 
     * @type {string}
     * @memberof SubscriptionGetResponseItems
     */
    object?: string;
    /**
     * 
     * @type {Array<SubscriptionGetResponseItemsData>}
     * @memberof SubscriptionGetResponseItems
     */
    data?: Array<SubscriptionGetResponseItemsData>;
    /**
     * 
     * @type {boolean}
     * @memberof SubscriptionGetResponseItems
     */
    has_more?: boolean;
    /**
     * 
     * @type {number}
     * @memberof SubscriptionGetResponseItems
     */
    total_count?: number;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionGetResponseItems
     */
    url?: string;
}
/**
 * 
 * @export
 * @interface SubscriptionGetResponseItemsData
 */
export interface SubscriptionGetResponseItemsData {
    /**
     * 
     * @type {string}
     * @memberof SubscriptionGetResponseItemsData
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionGetResponseItemsData
     */
    object?: string;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof SubscriptionGetResponseItemsData
     */
    billing_thresholds?: { [key: string]: object; };
    /**
     * 
     * @type {number}
     * @memberof SubscriptionGetResponseItemsData
     */
    created?: number;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof SubscriptionGetResponseItemsData
     */
    metadata?: { [key: string]: object; };
    /**
     * 
     * @type {SubscriptionGetResponseItemsPlan}
     * @memberof SubscriptionGetResponseItemsData
     */
    plan?: SubscriptionGetResponseItemsPlan;
    /**
     * 
     * @type {SubscriptionGetResponseItemsPrice}
     * @memberof SubscriptionGetResponseItemsData
     */
    price?: SubscriptionGetResponseItemsPrice;
}
/**
 * 
 * @export
 * @interface SubscriptionGetResponseItemsPlan
 */
export interface SubscriptionGetResponseItemsPlan {
    /**
     * 
     * @type {string}
     * @memberof SubscriptionGetResponseItemsPlan
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionGetResponseItemsPlan
     */
    object?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SubscriptionGetResponseItemsPlan
     */
    active?: boolean;
    /**
     * 
     * @type {number}
     * @memberof SubscriptionGetResponseItemsPlan
     */
    aggregate_usage?: number;
    /**
     * 
     * @type {number}
     * @memberof SubscriptionGetResponseItemsPlan
     */
    amount?: number;
    /**
     * 
     * @type {number}
     * @memberof SubscriptionGetResponseItemsPlan
     */
    amount_decimal?: number;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionGetResponseItemsPlan
     */
    billing_scheme?: string;
    /**
     * 
     * @type {number}
     * @memberof SubscriptionGetResponseItemsPlan
     */
    created?: number;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionGetResponseItemsPlan
     */
    currency?: string;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionGetResponseItemsPlan
     */
    interval?: string;
    /**
     * 
     * @type {number}
     * @memberof SubscriptionGetResponseItemsPlan
     */
    interval_count?: number;
    /**
     * 
     * @type {boolean}
     * @memberof SubscriptionGetResponseItemsPlan
     */
    livemode?: boolean;
    /**
     * 
     * @type {SubscriptionGetResponseItemsPlanMetadata}
     * @memberof SubscriptionGetResponseItemsPlan
     */
    metadata?: SubscriptionGetResponseItemsPlanMetadata;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionGetResponseItemsPlan
     */
    nickname?: string;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionGetResponseItemsPlan
     */
    product?: string;
    /**
     * 
     * @type {Array<SubscriptionGetResponseItemsPlanTiers>}
     * @memberof SubscriptionGetResponseItemsPlan
     */
    tiers?: Array<SubscriptionGetResponseItemsPlanTiers>;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionGetResponseItemsPlan
     */
    tiers_mode?: string;
    /**
     * 
     * @type {SubscriptionGetResponseItemsPlanTransformUsage}
     * @memberof SubscriptionGetResponseItemsPlan
     */
    transform_usage?: SubscriptionGetResponseItemsPlanTransformUsage;
    /**
     * 
     * @type {number}
     * @memberof SubscriptionGetResponseItemsPlan
     */
    trial_period_days?: number;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionGetResponseItemsPlan
     */
    usage_type?: string;
}
/**
 * 
 * @export
 * @interface SubscriptionGetResponseItemsPlanMetadata
 */
export interface SubscriptionGetResponseItemsPlanMetadata {
    /**
     * 
     * @type {string}
     * @memberof SubscriptionGetResponseItemsPlanMetadata
     */
    projects_limit?: string;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionGetResponseItemsPlanMetadata
     */
    artifact_limit?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SubscriptionGetResponseItemsPlanMetadata
     */
    export_artifact?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionGetResponseItemsPlanMetadata
     */
    max_disk_gb?: string;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionGetResponseItemsPlanMetadata
     */
    max_transfer_gb?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SubscriptionGetResponseItemsPlanMetadata
     */
    enable_subuser?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SubscriptionGetResponseItemsPlanMetadata
     */
    domain_setting?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SubscriptionGetResponseItemsPlanMetadata
     */
    email_notification?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SubscriptionGetResponseItemsPlanMetadata
     */
    slack_notification?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SubscriptionGetResponseItemsPlanMetadata
     */
    enable_webhook?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SubscriptionGetResponseItemsPlanMetadata
     */
    export_access_log?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SubscriptionGetResponseItemsPlanMetadata
     */
    media_cdn?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SubscriptionGetResponseItemsPlanMetadata
     */
    basic_auth?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SubscriptionGetResponseItemsPlanMetadata
     */
    auto_backup?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SubscriptionGetResponseItemsPlanMetadata
     */
    webhook_wp_launch?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SubscriptionGetResponseItemsPlanMetadata
     */
    export_backup?: boolean;
    /**
     * 
     * @type {number}
     * @memberof SubscriptionGetResponseItemsPlanMetadata
     */
    max_wp_start_request_day?: number;
}
/**
 * 
 * @export
 * @interface SubscriptionGetResponseItemsPlanTiers
 */
export interface SubscriptionGetResponseItemsPlanTiers {
    /**
     * 
     * @type {number}
     * @memberof SubscriptionGetResponseItemsPlanTiers
     */
    flat_amount?: number;
    /**
     * 
     * @type {number}
     * @memberof SubscriptionGetResponseItemsPlanTiers
     */
    flat_amount_decimal?: number;
    /**
     * 
     * @type {number}
     * @memberof SubscriptionGetResponseItemsPlanTiers
     */
    unit_amount?: number;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionGetResponseItemsPlanTiers
     */
    unit_amount_decimal?: string;
    /**
     * 
     * @type {number}
     * @memberof SubscriptionGetResponseItemsPlanTiers
     */
    up_to?: number;
}
/**
 * 
 * @export
 * @interface SubscriptionGetResponseItemsPlanTransformUsage
 */
export interface SubscriptionGetResponseItemsPlanTransformUsage {
    /**
     * 
     * @type {number}
     * @memberof SubscriptionGetResponseItemsPlanTransformUsage
     */
    divide_by?: number;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionGetResponseItemsPlanTransformUsage
     */
    round?: string;
}
/**
 * 
 * @export
 * @interface SubscriptionGetResponseItemsPrice
 */
export interface SubscriptionGetResponseItemsPrice {
    /**
     * 
     * @type {string}
     * @memberof SubscriptionGetResponseItemsPrice
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionGetResponseItemsPrice
     */
    object?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SubscriptionGetResponseItemsPrice
     */
    active?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionGetResponseItemsPrice
     */
    billing_scheme?: string;
    /**
     * 
     * @type {number}
     * @memberof SubscriptionGetResponseItemsPrice
     */
    created?: number;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionGetResponseItemsPrice
     */
    currency?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SubscriptionGetResponseItemsPrice
     */
    livemode?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionGetResponseItemsPrice
     */
    lookup_key?: string;
    /**
     * 
     * @type {SubscriptionGetResponseItemsPlanMetadata}
     * @memberof SubscriptionGetResponseItemsPrice
     */
    metadata?: SubscriptionGetResponseItemsPlanMetadata;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionGetResponseItemsPrice
     */
    nickname?: string;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionGetResponseItemsPrice
     */
    product?: string;
    /**
     * 
     * @type {SubscriptionGetResponseItemsPriceRecurring}
     * @memberof SubscriptionGetResponseItemsPrice
     */
    recurring?: SubscriptionGetResponseItemsPriceRecurring;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionGetResponseItemsPrice
     */
    tiers_mode?: string;
    /**
     * 
     * @type {number}
     * @memberof SubscriptionGetResponseItemsPrice
     */
    transform_quantity?: number;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionGetResponseItemsPrice
     */
    type?: string;
    /**
     * 
     * @type {number}
     * @memberof SubscriptionGetResponseItemsPrice
     */
    unit_amount?: number;
    /**
     * 
     * @type {number}
     * @memberof SubscriptionGetResponseItemsPrice
     */
    unit_amount_decimal?: number;
    /**
     * 
     * @type {number}
     * @memberof SubscriptionGetResponseItemsPrice
     */
    quantity?: number;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionGetResponseItemsPrice
     */
    subscription?: string;
    /**
     * 
     * @type {SubscriptionGetResponseDefaultTaxRates}
     * @memberof SubscriptionGetResponseItemsPrice
     */
    tax_rates?: SubscriptionGetResponseDefaultTaxRates;
}
/**
 * 
 * @export
 * @interface SubscriptionGetResponseItemsPriceRecurring
 */
export interface SubscriptionGetResponseItemsPriceRecurring {
    /**
     * 
     * @type {string}
     * @memberof SubscriptionGetResponseItemsPriceRecurring
     */
    aggregate_usage?: string;
    /**
     * 
     * @type {number}
     * @memberof SubscriptionGetResponseItemsPriceRecurring
     */
    interval?: number;
    /**
     * 
     * @type {number}
     * @memberof SubscriptionGetResponseItemsPriceRecurring
     */
    interval_count?: number;
    /**
     * 
     * @type {number}
     * @memberof SubscriptionGetResponseItemsPriceRecurring
     */
    trial_period_days?: number;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionGetResponseItemsPriceRecurring
     */
    usage_type?: string;
}
/**
 * 
 * @export
 * @interface SubscriptionGetResponsePauseCollection
 */
export interface SubscriptionGetResponsePauseCollection {
    /**
     * 
     * @type {string}
     * @memberof SubscriptionGetResponsePauseCollection
     */
    behavior?: string;
    /**
     * 
     * @type {number}
     * @memberof SubscriptionGetResponsePauseCollection
     */
    resume_at?: number;
}
/**
 * 
 * @export
 * @interface SubscriptionGetResponsePendingInvoiceItemInterval
 */
export interface SubscriptionGetResponsePendingInvoiceItemInterval {
    /**
     * 
     * @type {string}
     * @memberof SubscriptionGetResponsePendingInvoiceItemInterval
     */
    interval?: string;
    /**
     * 
     * @type {number}
     * @memberof SubscriptionGetResponsePendingInvoiceItemInterval
     */
    interval_count?: number;
}
/**
 * 
 * @export
 * @interface SubscriptionGetResponsePendingUpdate
 */
export interface SubscriptionGetResponsePendingUpdate {
    /**
     * 
     * @type {number}
     * @memberof SubscriptionGetResponsePendingUpdate
     */
    billing_cycle_anchor?: number;
    /**
     * 
     * @type {number}
     * @memberof SubscriptionGetResponsePendingUpdate
     */
    expires_at?: number;
    /**
     * 
     * @type {Array<{ [key: string]: object; }>}
     * @memberof SubscriptionGetResponsePendingUpdate
     */
    subscription_items?: Array<{ [key: string]: object; }>;
}
/**
 * 
 * @export
 * @interface SubscriptionGetResponseTransferData
 */
export interface SubscriptionGetResponseTransferData {
    /**
     * 
     * @type {number}
     * @memberof SubscriptionGetResponseTransferData
     */
    amount?: number;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionGetResponseTransferData
     */
    destination?: string;
}
/**
 * 
 * @export
 * @interface SubscriptionUpdateResponse
 */
export interface SubscriptionUpdateResponse {
    /**
     * Subscription ID
     * @type {string}
     * @memberof SubscriptionUpdateResponse
     */
    id?: string;
    /**
     * New subscription ID
     * @type {string}
     * @memberof SubscriptionUpdateResponse
     */
    new_subscription_id?: string;
}
/**
 * 
 * @export
 * @interface TeamsResponseWithId
 */
export interface TeamsResponseWithId {
    /**
     * 
     * @type {string}
     * @memberof TeamsResponseWithId
     */
    team_id?: string;
    /**
     * 
     * @type {string}
     * @memberof TeamsResponseWithId
     */
    team_name?: string;
    /**
     * 
     * @type {string}
     * @memberof TeamsResponseWithId
     */
    team_website?: string;
    /**
     * 
     * @type {string}
     * @memberof TeamsResponseWithId
     */
    phone_number?: string;
    /**
     * 
     * @type {string}
     * @memberof TeamsResponseWithId
     */
    team_country?: string;
    /**
     * 
     * @type {string}
     * @memberof TeamsResponseWithId
     */
    team_state?: string;
    /**
     * 
     * @type {string}
     * @memberof TeamsResponseWithId
     */
    team_twitter?: string;
    /**
     * 
     * @type {string}
     * @memberof TeamsResponseWithId
     */
    team_size?: string;
}
/**
 * 
 * @export
 * @interface TeamsResponseWithoutId
 */
export interface TeamsResponseWithoutId {
    /**
     * 
     * @type {string}
     * @memberof TeamsResponseWithoutId
     */
    team_name?: string;
    /**
     * 
     * @type {string}
     * @memberof TeamsResponseWithoutId
     */
    team_website?: string;
    /**
     * 
     * @type {string}
     * @memberof TeamsResponseWithoutId
     */
    phone_number?: string;
    /**
     * 
     * @type {string}
     * @memberof TeamsResponseWithoutId
     */
    team_country?: string;
    /**
     * 
     * @type {string}
     * @memberof TeamsResponseWithoutId
     */
    team_state?: string;
    /**
     * 
     * @type {string}
     * @memberof TeamsResponseWithoutId
     */
    team_twitter?: string;
    /**
     * 
     * @type {string}
     * @memberof TeamsResponseWithoutId
     */
    team_size?: string;
}
/**
 * 
 * @export
 * @interface UsageSummaryGetResponse
 */
export interface UsageSummaryGetResponse {
    /**
     * Time that previous update of statistics
     * @type {string}
     * @memberof UsageSummaryGetResponse
     */
    update_time?: string;
    /**
     * Number of sites
     * @type {number}
     * @memberof UsageSummaryGetResponse
     */
    sites_count?: number;
    /**
     * Total giga bytes of storage usage.
     * @type {number}
     * @memberof UsageSummaryGetResponse
     */
    disk_total?: number;
    /**
     * Total transfer giga bytes
     * @type {number}
     * @memberof UsageSummaryGetResponse
     */
    transfer_total?: number;
    /**
     * Shifter account name
     * @type {string}
     * @memberof UsageSummaryGetResponse
     */
    user_name?: string;
    /**
     * Target month of statistics
     * @type {number}
     * @memberof UsageSummaryGetResponse
     */
    track_month?: number;
}

/**
 * AccountApi - axios parameter creator
 * @export
 */
export const AccountApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Check user is valid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountAvailablePost: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/account/available`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * You can delete your account. An invited user cannot be accessed this API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update address which will be written it to the invoice
         * @param {InlineObject27} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountInvoiceAddressPost: async (request?: InlineObject27, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/account/invoice_address`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get events of user authentication
         * @param {number} [maxResults] number of authentication results. maximum 60.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountLogAuthEventsGet: async (maxResults?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/account/log/auth_events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (maxResults !== undefined) {
                localVarQueryParameter['max_results'] = maxResults;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Synchronize your email to stripe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountNotificationEmailSynchronizationPost: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/account/notification/email/synchronization`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adding your email destination when sending some notifications
         * @param {'email'} target 
         * @param {InlineObject26} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountNotificationTargetPost: async (target: 'email', request?: InlineObject26, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'target' is not null or undefined
            assertParamExists('accountNotificationTargetPost', 'target', target)
            const localVarPath = `/account/notification/{target}`
                .replace(`{${"target"}}`, encodeURIComponent(String(target)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountApi - functional programming interface
 * @export
 */
export const AccountApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountApiAxiosParamCreator(configuration)
    return {
        /**
         * Check user is valid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountAvailablePost(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2015>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountAvailablePost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * You can delete your account. An invited user cannot be accessed this API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update address which will be written it to the invoice
         * @param {InlineObject27} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountInvoiceAddressPost(request?: InlineObject27, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountInvoiceAddressPost(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get events of user authentication
         * @param {number} [maxResults] number of authentication results. maximum 60.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountLogAuthEventsGet(maxResults?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse20012>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountLogAuthEventsGet(maxResults, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Synchronize your email to stripe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountNotificationEmailSynchronizationPost(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountNotificationEmailSynchronizationPost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adding your email destination when sending some notifications
         * @param {'email'} target 
         * @param {InlineObject26} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountNotificationTargetPost(target: 'email', request?: InlineObject26, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountNotificationTargetPost(target, request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccountApi - factory interface
 * @export
 */
export const AccountApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountApiFp(configuration)
    return {
        /**
         * Check user is valid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountAvailablePost(options?: any): AxiosPromise<InlineResponse2015> {
            return localVarFp.accountAvailablePost(options).then((request) => request(axios, basePath));
        },
        /**
         * You can delete your account. An invited user cannot be accessed this API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountDelete(options?: any): AxiosPromise<void> {
            return localVarFp.accountDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * Update address which will be written it to the invoice
         * @param {InlineObject27} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountInvoiceAddressPost(request?: InlineObject27, options?: any): AxiosPromise<void> {
            return localVarFp.accountInvoiceAddressPost(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Get events of user authentication
         * @param {number} [maxResults] number of authentication results. maximum 60.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountLogAuthEventsGet(maxResults?: number, options?: any): AxiosPromise<Array<InlineResponse20012>> {
            return localVarFp.accountLogAuthEventsGet(maxResults, options).then((request) => request(axios, basePath));
        },
        /**
         * Synchronize your email to stripe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountNotificationEmailSynchronizationPost(options?: any): AxiosPromise<void> {
            return localVarFp.accountNotificationEmailSynchronizationPost(options).then((request) => request(axios, basePath));
        },
        /**
         * Adding your email destination when sending some notifications
         * @param {'email'} target 
         * @param {InlineObject26} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountNotificationTargetPost(target: 'email', request?: InlineObject26, options?: any): AxiosPromise<void> {
            return localVarFp.accountNotificationTargetPost(target, request, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountApi - object-oriented interface
 * @export
 * @class AccountApi
 * @extends {BaseAPI}
 */
export class AccountApi extends BaseAPI {
    /**
     * Check user is valid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountAvailablePost(options?: any) {
        return AccountApiFp(this.configuration).accountAvailablePost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You can delete your account. An invited user cannot be accessed this API.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountDelete(options?: any) {
        return AccountApiFp(this.configuration).accountDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update address which will be written it to the invoice
     * @param {InlineObject27} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountInvoiceAddressPost(request?: InlineObject27, options?: any) {
        return AccountApiFp(this.configuration).accountInvoiceAddressPost(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get events of user authentication
     * @param {number} [maxResults] number of authentication results. maximum 60.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountLogAuthEventsGet(maxResults?: number, options?: any) {
        return AccountApiFp(this.configuration).accountLogAuthEventsGet(maxResults, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Synchronize your email to stripe
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountNotificationEmailSynchronizationPost(options?: any) {
        return AccountApiFp(this.configuration).accountNotificationEmailSynchronizationPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adding your email destination when sending some notifications
     * @param {'email'} target 
     * @param {InlineObject26} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountNotificationTargetPost(target: 'email', request?: InlineObject26, options?: any) {
        return AccountApiFp(this.configuration).accountNotificationTargetPost(target, request, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ArtifactsApi - axios parameter creator
 * @export
 */
export const ArtifactsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get the URL of the artifact. All published assets of the site is included.
         * @param {string} projectId Site ID
         * @param {string} artifactId Artifact ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsProjectIdArtifactsArtifactIdDownloadUrlGet: async (projectId: string, artifactId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('projectsProjectIdArtifactsArtifactIdDownloadUrlGet', 'projectId', projectId)
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('projectsProjectIdArtifactsArtifactIdDownloadUrlGet', 'artifactId', artifactId)
            const localVarPath = `/projects/{project_id}/artifacts/{artifact_id}/download_url`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"artifact_id"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update your artifact name.
         * @param {string} siteId Site ID
         * @param {string} artifactId Artifact ID
         * @param {InlineObject24} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdArtifactsArtifactIdArtifactNamePut: async (siteId: string, artifactId: string, request: InlineObject24, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteId' is not null or undefined
            assertParamExists('sitesSiteIdArtifactsArtifactIdArtifactNamePut', 'siteId', siteId)
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('sitesSiteIdArtifactsArtifactIdArtifactNamePut', 'artifactId', artifactId)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('sitesSiteIdArtifactsArtifactIdArtifactNamePut', 'request', request)
            const localVarPath = `/sites/{site_id}/artifacts/{artifact_id}/artifact_name`
                .replace(`{${"site_id"}}`, encodeURIComponent(String(siteId)))
                .replace(`{${"artifact_id"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve path of WordPress from backup archive
         * @param {string} siteId Site ID
         * @param {string} artifactId Artifact ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdArtifactsArtifactIdBackupUrlGet: async (siteId: string, artifactId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteId' is not null or undefined
            assertParamExists('sitesSiteIdArtifactsArtifactIdBackupUrlGet', 'siteId', siteId)
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('sitesSiteIdArtifactsArtifactIdBackupUrlGet', 'artifactId', artifactId)
            const localVarPath = `/sites/{site_id}/artifacts/{artifact_id}/backup_url`
                .replace(`{${"site_id"}}`, encodeURIComponent(String(siteId)))
                .replace(`{${"artifact_id"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete artifacts
         * @param {string} siteId Site ID
         * @param {string} artifactId Artifact ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdArtifactsArtifactIdDelete: async (siteId: string, artifactId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteId' is not null or undefined
            assertParamExists('sitesSiteIdArtifactsArtifactIdDelete', 'siteId', siteId)
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('sitesSiteIdArtifactsArtifactIdDelete', 'artifactId', artifactId)
            const localVarPath = `/sites/{site_id}/artifacts/{artifact_id}`
                .replace(`{${"site_id"}}`, encodeURIComponent(String(siteId)))
                .replace(`{${"artifact_id"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set the artifact to public on the CDN
         * @param {string} siteId Site ID
         * @param {string} artifactId Artifact ID
         * @param {string} deployType Deployment Type (only shifter_cdn)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdArtifactsArtifactIdDeployDeployTypePost: async (siteId: string, artifactId: string, deployType: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteId' is not null or undefined
            assertParamExists('sitesSiteIdArtifactsArtifactIdDeployDeployTypePost', 'siteId', siteId)
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('sitesSiteIdArtifactsArtifactIdDeployDeployTypePost', 'artifactId', artifactId)
            // verify required parameter 'deployType' is not null or undefined
            assertParamExists('sitesSiteIdArtifactsArtifactIdDeployDeployTypePost', 'deployType', deployType)
            const localVarPath = `/sites/{site_id}/artifacts/{artifact_id}/deploy/{deploy_type}`
                .replace(`{${"site_id"}}`, encodeURIComponent(String(siteId)))
                .replace(`{${"artifact_id"}}`, encodeURIComponent(String(artifactId)))
                .replace(`{${"deploy_type"}}`, encodeURIComponent(String(deployType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the URL of the artifact. All published assets of the site is included.
         * @param {string} siteId Site ID
         * @param {string} artifactId Artifact ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdArtifactsArtifactIdDownloadUrlGet: async (siteId: string, artifactId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteId' is not null or undefined
            assertParamExists('sitesSiteIdArtifactsArtifactIdDownloadUrlGet', 'siteId', siteId)
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('sitesSiteIdArtifactsArtifactIdDownloadUrlGet', 'artifactId', artifactId)
            const localVarPath = `/sites/{site_id}/artifacts/{artifact_id}/download_url`
                .replace(`{${"site_id"}}`, encodeURIComponent(String(siteId)))
                .replace(`{${"artifact_id"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stop generating process
         * @param {string} siteId Site ID
         * @param {string} artifactId Artifact ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdArtifactsArtifactIdGeneratorDelete: async (siteId: string, artifactId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteId' is not null or undefined
            assertParamExists('sitesSiteIdArtifactsArtifactIdGeneratorDelete', 'siteId', siteId)
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('sitesSiteIdArtifactsArtifactIdGeneratorDelete', 'artifactId', artifactId)
            const localVarPath = `/sites/{site_id}/artifacts/{artifact_id}/generator`
                .replace(`{${"site_id"}}`, encodeURIComponent(String(siteId)))
                .replace(`{${"artifact_id"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Enable artifact previews
         * @param {string} siteId Site ID
         * @param {string} artifactId Artifact ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdArtifactsArtifactIdPreviewPost: async (siteId: string, artifactId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteId' is not null or undefined
            assertParamExists('sitesSiteIdArtifactsArtifactIdPreviewPost', 'siteId', siteId)
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('sitesSiteIdArtifactsArtifactIdPreviewPost', 'artifactId', artifactId)
            const localVarPath = `/sites/{site_id}/artifacts/{artifact_id}/preview`
                .replace(`{${"site_id"}}`, encodeURIComponent(String(siteId)))
                .replace(`{${"artifact_id"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete scheduled publish
         * @param {string} siteId Site ID
         * @param {string} artifactId Artifact ID
         * @param {string} jobId Schedule Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdArtifactsArtifactIdPublishJobIdDelete: async (siteId: string, artifactId: string, jobId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteId' is not null or undefined
            assertParamExists('sitesSiteIdArtifactsArtifactIdPublishJobIdDelete', 'siteId', siteId)
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('sitesSiteIdArtifactsArtifactIdPublishJobIdDelete', 'artifactId', artifactId)
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('sitesSiteIdArtifactsArtifactIdPublishJobIdDelete', 'jobId', jobId)
            const localVarPath = `/sites/{site_id}/artifacts/{artifact_id}/publish/{job_id}`
                .replace(`{${"site_id"}}`, encodeURIComponent(String(siteId)))
                .replace(`{${"artifact_id"}}`, encodeURIComponent(String(artifactId)))
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update publish schedule
         * @param {string} siteId Site ID
         * @param {string} artifactId Artifact ID
         * @param {string} jobId Schedule Job ID
         * @param {InlineObject23} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdArtifactsArtifactIdPublishJobIdPost: async (siteId: string, artifactId: string, jobId: string, request: InlineObject23, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteId' is not null or undefined
            assertParamExists('sitesSiteIdArtifactsArtifactIdPublishJobIdPost', 'siteId', siteId)
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('sitesSiteIdArtifactsArtifactIdPublishJobIdPost', 'artifactId', artifactId)
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('sitesSiteIdArtifactsArtifactIdPublishJobIdPost', 'jobId', jobId)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('sitesSiteIdArtifactsArtifactIdPublishJobIdPost', 'request', request)
            const localVarPath = `/sites/{site_id}/artifacts/{artifact_id}/publish/{job_id}`
                .replace(`{${"site_id"}}`, encodeURIComponent(String(siteId)))
                .replace(`{${"artifact_id"}}`, encodeURIComponent(String(artifactId)))
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set the artifact to public on the Shifter CDN. OR Set the publish date of the artifact
         * @param {string} siteId Site ID
         * @param {string} artifactId Artifact ID
         * @param {InlineObject22} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdArtifactsArtifactIdPublishPost: async (siteId: string, artifactId: string, request?: InlineObject22, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteId' is not null or undefined
            assertParamExists('sitesSiteIdArtifactsArtifactIdPublishPost', 'siteId', siteId)
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('sitesSiteIdArtifactsArtifactIdPublishPost', 'artifactId', artifactId)
            const localVarPath = `/sites/{site_id}/artifacts/{artifact_id}/publish`
                .replace(`{${"site_id"}}`, encodeURIComponent(String(siteId)))
                .replace(`{${"artifact_id"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * execute webhook of specific artifact
         * @param {string} siteId 
         * @param {string} artifactId 
         * @param {InlineObject25} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdArtifactsArtifactIdWebhookRunnerPost: async (siteId: string, artifactId: string, request?: InlineObject25, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteId' is not null or undefined
            assertParamExists('sitesSiteIdArtifactsArtifactIdWebhookRunnerPost', 'siteId', siteId)
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('sitesSiteIdArtifactsArtifactIdWebhookRunnerPost', 'artifactId', artifactId)
            const localVarPath = `/sites/{site_id}/artifacts/{artifact_id}/webhook_runner`
                .replace(`{${"site_id"}}`, encodeURIComponent(String(siteId)))
                .replace(`{${"artifact_id"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all artifacts.
         * @param {string} siteId Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdArtifactsGet: async (siteId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteId' is not null or undefined
            assertParamExists('sitesSiteIdArtifactsGet', 'siteId', siteId)
            const localVarPath = `/sites/{site_id}/artifacts`
                .replace(`{${"site_id"}}`, encodeURIComponent(String(siteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generate artifact.
         * @param {string} siteId Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdArtifactsPost: async (siteId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteId' is not null or undefined
            assertParamExists('sitesSiteIdArtifactsPost', 'siteId', siteId)
            const localVarPath = `/sites/{site_id}/artifacts`
                .replace(`{${"site_id"}}`, encodeURIComponent(String(siteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * You can get the process of generating
         * @param {string} siteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdCheckGeneratorProcessGet: async (siteId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteId' is not null or undefined
            assertParamExists('sitesSiteIdCheckGeneratorProcessGet', 'siteId', siteId)
            const localVarPath = `/sites/{site_id}/check_generator_process`
                .replace(`{${"site_id"}}`, encodeURIComponent(String(siteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ArtifactsApi - functional programming interface
 * @export
 */
export const ArtifactsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ArtifactsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get the URL of the artifact. All published assets of the site is included.
         * @param {string} projectId Site ID
         * @param {string} artifactId Artifact ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsProjectIdArtifactsArtifactIdDownloadUrlGet(projectId: string, artifactId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtifactDownloadResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsProjectIdArtifactsArtifactIdDownloadUrlGet(projectId, artifactId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update your artifact name.
         * @param {string} siteId Site ID
         * @param {string} artifactId Artifact ID
         * @param {InlineObject24} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitesSiteIdArtifactsArtifactIdArtifactNamePut(siteId: string, artifactId: string, request: InlineObject24, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitesSiteIdArtifactsArtifactIdArtifactNamePut(siteId, artifactId, request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve path of WordPress from backup archive
         * @param {string} siteId Site ID
         * @param {string} artifactId Artifact ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitesSiteIdArtifactsArtifactIdBackupUrlGet(siteId: string, artifactId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2008>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitesSiteIdArtifactsArtifactIdBackupUrlGet(siteId, artifactId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete artifacts
         * @param {string} siteId Site ID
         * @param {string} artifactId Artifact ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitesSiteIdArtifactsArtifactIdDelete(siteId: string, artifactId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitesSiteIdArtifactsArtifactIdDelete(siteId, artifactId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Set the artifact to public on the CDN
         * @param {string} siteId Site ID
         * @param {string} artifactId Artifact ID
         * @param {string} deployType Deployment Type (only shifter_cdn)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitesSiteIdArtifactsArtifactIdDeployDeployTypePost(siteId: string, artifactId: string, deployType: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitesSiteIdArtifactsArtifactIdDeployDeployTypePost(siteId, artifactId, deployType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the URL of the artifact. All published assets of the site is included.
         * @param {string} siteId Site ID
         * @param {string} artifactId Artifact ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitesSiteIdArtifactsArtifactIdDownloadUrlGet(siteId: string, artifactId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtifactDownloadResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitesSiteIdArtifactsArtifactIdDownloadUrlGet(siteId, artifactId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Stop generating process
         * @param {string} siteId Site ID
         * @param {string} artifactId Artifact ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitesSiteIdArtifactsArtifactIdGeneratorDelete(siteId: string, artifactId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitesSiteIdArtifactsArtifactIdGeneratorDelete(siteId, artifactId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Enable artifact previews
         * @param {string} siteId Site ID
         * @param {string} artifactId Artifact ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitesSiteIdArtifactsArtifactIdPreviewPost(siteId: string, artifactId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitesSiteIdArtifactsArtifactIdPreviewPost(siteId, artifactId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete scheduled publish
         * @param {string} siteId Site ID
         * @param {string} artifactId Artifact ID
         * @param {string} jobId Schedule Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitesSiteIdArtifactsArtifactIdPublishJobIdDelete(siteId: string, artifactId: string, jobId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitesSiteIdArtifactsArtifactIdPublishJobIdDelete(siteId, artifactId, jobId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update publish schedule
         * @param {string} siteId Site ID
         * @param {string} artifactId Artifact ID
         * @param {string} jobId Schedule Job ID
         * @param {InlineObject23} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitesSiteIdArtifactsArtifactIdPublishJobIdPost(siteId: string, artifactId: string, jobId: string, request: InlineObject23, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2014>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitesSiteIdArtifactsArtifactIdPublishJobIdPost(siteId, artifactId, jobId, request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Set the artifact to public on the Shifter CDN. OR Set the publish date of the artifact
         * @param {string} siteId Site ID
         * @param {string} artifactId Artifact ID
         * @param {InlineObject22} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitesSiteIdArtifactsArtifactIdPublishPost(siteId: string, artifactId: string, request?: InlineObject22, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2013>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitesSiteIdArtifactsArtifactIdPublishPost(siteId, artifactId, request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * execute webhook of specific artifact
         * @param {string} siteId 
         * @param {string} artifactId 
         * @param {InlineObject25} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitesSiteIdArtifactsArtifactIdWebhookRunnerPost(siteId: string, artifactId: string, request?: InlineObject25, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitesSiteIdArtifactsArtifactIdWebhookRunnerPost(siteId, artifactId, request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all artifacts.
         * @param {string} siteId Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitesSiteIdArtifactsGet(siteId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtifactGetResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitesSiteIdArtifactsGet(siteId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Generate artifact.
         * @param {string} siteId Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitesSiteIdArtifactsPost(siteId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitesSiteIdArtifactsPost(siteId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * You can get the process of generating
         * @param {string} siteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitesSiteIdCheckGeneratorProcessGet(siteId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitesSiteIdCheckGeneratorProcessGet(siteId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ArtifactsApi - factory interface
 * @export
 */
export const ArtifactsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ArtifactsApiFp(configuration)
    return {
        /**
         * Get the URL of the artifact. All published assets of the site is included.
         * @param {string} projectId Site ID
         * @param {string} artifactId Artifact ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsProjectIdArtifactsArtifactIdDownloadUrlGet(projectId: string, artifactId: string, options?: any): AxiosPromise<ArtifactDownloadResponse> {
            return localVarFp.projectsProjectIdArtifactsArtifactIdDownloadUrlGet(projectId, artifactId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update your artifact name.
         * @param {string} siteId Site ID
         * @param {string} artifactId Artifact ID
         * @param {InlineObject24} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdArtifactsArtifactIdArtifactNamePut(siteId: string, artifactId: string, request: InlineObject24, options?: any): AxiosPromise<void> {
            return localVarFp.sitesSiteIdArtifactsArtifactIdArtifactNamePut(siteId, artifactId, request, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve path of WordPress from backup archive
         * @param {string} siteId Site ID
         * @param {string} artifactId Artifact ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdArtifactsArtifactIdBackupUrlGet(siteId: string, artifactId: string, options?: any): AxiosPromise<InlineResponse2008> {
            return localVarFp.sitesSiteIdArtifactsArtifactIdBackupUrlGet(siteId, artifactId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete artifacts
         * @param {string} siteId Site ID
         * @param {string} artifactId Artifact ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdArtifactsArtifactIdDelete(siteId: string, artifactId: string, options?: any): AxiosPromise<void> {
            return localVarFp.sitesSiteIdArtifactsArtifactIdDelete(siteId, artifactId, options).then((request) => request(axios, basePath));
        },
        /**
         * Set the artifact to public on the CDN
         * @param {string} siteId Site ID
         * @param {string} artifactId Artifact ID
         * @param {string} deployType Deployment Type (only shifter_cdn)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdArtifactsArtifactIdDeployDeployTypePost(siteId: string, artifactId: string, deployType: string, options?: any): AxiosPromise<void> {
            return localVarFp.sitesSiteIdArtifactsArtifactIdDeployDeployTypePost(siteId, artifactId, deployType, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the URL of the artifact. All published assets of the site is included.
         * @param {string} siteId Site ID
         * @param {string} artifactId Artifact ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdArtifactsArtifactIdDownloadUrlGet(siteId: string, artifactId: string, options?: any): AxiosPromise<ArtifactDownloadResponse> {
            return localVarFp.sitesSiteIdArtifactsArtifactIdDownloadUrlGet(siteId, artifactId, options).then((request) => request(axios, basePath));
        },
        /**
         * Stop generating process
         * @param {string} siteId Site ID
         * @param {string} artifactId Artifact ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdArtifactsArtifactIdGeneratorDelete(siteId: string, artifactId: string, options?: any): AxiosPromise<void> {
            return localVarFp.sitesSiteIdArtifactsArtifactIdGeneratorDelete(siteId, artifactId, options).then((request) => request(axios, basePath));
        },
        /**
         * Enable artifact previews
         * @param {string} siteId Site ID
         * @param {string} artifactId Artifact ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdArtifactsArtifactIdPreviewPost(siteId: string, artifactId: string, options?: any): AxiosPromise<void> {
            return localVarFp.sitesSiteIdArtifactsArtifactIdPreviewPost(siteId, artifactId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete scheduled publish
         * @param {string} siteId Site ID
         * @param {string} artifactId Artifact ID
         * @param {string} jobId Schedule Job ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdArtifactsArtifactIdPublishJobIdDelete(siteId: string, artifactId: string, jobId: string, options?: any): AxiosPromise<void> {
            return localVarFp.sitesSiteIdArtifactsArtifactIdPublishJobIdDelete(siteId, artifactId, jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update publish schedule
         * @param {string} siteId Site ID
         * @param {string} artifactId Artifact ID
         * @param {string} jobId Schedule Job ID
         * @param {InlineObject23} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdArtifactsArtifactIdPublishJobIdPost(siteId: string, artifactId: string, jobId: string, request: InlineObject23, options?: any): AxiosPromise<InlineResponse2014> {
            return localVarFp.sitesSiteIdArtifactsArtifactIdPublishJobIdPost(siteId, artifactId, jobId, request, options).then((request) => request(axios, basePath));
        },
        /**
         * Set the artifact to public on the Shifter CDN. OR Set the publish date of the artifact
         * @param {string} siteId Site ID
         * @param {string} artifactId Artifact ID
         * @param {InlineObject22} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdArtifactsArtifactIdPublishPost(siteId: string, artifactId: string, request?: InlineObject22, options?: any): AxiosPromise<InlineResponse2013> {
            return localVarFp.sitesSiteIdArtifactsArtifactIdPublishPost(siteId, artifactId, request, options).then((request) => request(axios, basePath));
        },
        /**
         * execute webhook of specific artifact
         * @param {string} siteId 
         * @param {string} artifactId 
         * @param {InlineObject25} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdArtifactsArtifactIdWebhookRunnerPost(siteId: string, artifactId: string, request?: InlineObject25, options?: any): AxiosPromise<void> {
            return localVarFp.sitesSiteIdArtifactsArtifactIdWebhookRunnerPost(siteId, artifactId, request, options).then((request) => request(axios, basePath));
        },
        /**
         * List all artifacts.
         * @param {string} siteId Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdArtifactsGet(siteId: string, options?: any): AxiosPromise<Array<ArtifactGetResponse>> {
            return localVarFp.sitesSiteIdArtifactsGet(siteId, options).then((request) => request(axios, basePath));
        },
        /**
         * Generate artifact.
         * @param {string} siteId Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdArtifactsPost(siteId: string, options?: any): AxiosPromise<object> {
            return localVarFp.sitesSiteIdArtifactsPost(siteId, options).then((request) => request(axios, basePath));
        },
        /**
         * You can get the process of generating
         * @param {string} siteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdCheckGeneratorProcessGet(siteId: string, options?: any): AxiosPromise<object> {
            return localVarFp.sitesSiteIdCheckGeneratorProcessGet(siteId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ArtifactsApi - object-oriented interface
 * @export
 * @class ArtifactsApi
 * @extends {BaseAPI}
 */
export class ArtifactsApi extends BaseAPI {
    /**
     * Get the URL of the artifact. All published assets of the site is included.
     * @param {string} projectId Site ID
     * @param {string} artifactId Artifact ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactsApi
     */
    public projectsProjectIdArtifactsArtifactIdDownloadUrlGet(projectId: string, artifactId: string, options?: any) {
        return ArtifactsApiFp(this.configuration).projectsProjectIdArtifactsArtifactIdDownloadUrlGet(projectId, artifactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update your artifact name.
     * @param {string} siteId Site ID
     * @param {string} artifactId Artifact ID
     * @param {InlineObject24} request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactsApi
     */
    public sitesSiteIdArtifactsArtifactIdArtifactNamePut(siteId: string, artifactId: string, request: InlineObject24, options?: any) {
        return ArtifactsApiFp(this.configuration).sitesSiteIdArtifactsArtifactIdArtifactNamePut(siteId, artifactId, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve path of WordPress from backup archive
     * @param {string} siteId Site ID
     * @param {string} artifactId Artifact ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactsApi
     */
    public sitesSiteIdArtifactsArtifactIdBackupUrlGet(siteId: string, artifactId: string, options?: any) {
        return ArtifactsApiFp(this.configuration).sitesSiteIdArtifactsArtifactIdBackupUrlGet(siteId, artifactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete artifacts
     * @param {string} siteId Site ID
     * @param {string} artifactId Artifact ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactsApi
     */
    public sitesSiteIdArtifactsArtifactIdDelete(siteId: string, artifactId: string, options?: any) {
        return ArtifactsApiFp(this.configuration).sitesSiteIdArtifactsArtifactIdDelete(siteId, artifactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set the artifact to public on the CDN
     * @param {string} siteId Site ID
     * @param {string} artifactId Artifact ID
     * @param {string} deployType Deployment Type (only shifter_cdn)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactsApi
     */
    public sitesSiteIdArtifactsArtifactIdDeployDeployTypePost(siteId: string, artifactId: string, deployType: string, options?: any) {
        return ArtifactsApiFp(this.configuration).sitesSiteIdArtifactsArtifactIdDeployDeployTypePost(siteId, artifactId, deployType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the URL of the artifact. All published assets of the site is included.
     * @param {string} siteId Site ID
     * @param {string} artifactId Artifact ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactsApi
     */
    public sitesSiteIdArtifactsArtifactIdDownloadUrlGet(siteId: string, artifactId: string, options?: any) {
        return ArtifactsApiFp(this.configuration).sitesSiteIdArtifactsArtifactIdDownloadUrlGet(siteId, artifactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Stop generating process
     * @param {string} siteId Site ID
     * @param {string} artifactId Artifact ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactsApi
     */
    public sitesSiteIdArtifactsArtifactIdGeneratorDelete(siteId: string, artifactId: string, options?: any) {
        return ArtifactsApiFp(this.configuration).sitesSiteIdArtifactsArtifactIdGeneratorDelete(siteId, artifactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Enable artifact previews
     * @param {string} siteId Site ID
     * @param {string} artifactId Artifact ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactsApi
     */
    public sitesSiteIdArtifactsArtifactIdPreviewPost(siteId: string, artifactId: string, options?: any) {
        return ArtifactsApiFp(this.configuration).sitesSiteIdArtifactsArtifactIdPreviewPost(siteId, artifactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete scheduled publish
     * @param {string} siteId Site ID
     * @param {string} artifactId Artifact ID
     * @param {string} jobId Schedule Job ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactsApi
     */
    public sitesSiteIdArtifactsArtifactIdPublishJobIdDelete(siteId: string, artifactId: string, jobId: string, options?: any) {
        return ArtifactsApiFp(this.configuration).sitesSiteIdArtifactsArtifactIdPublishJobIdDelete(siteId, artifactId, jobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update publish schedule
     * @param {string} siteId Site ID
     * @param {string} artifactId Artifact ID
     * @param {string} jobId Schedule Job ID
     * @param {InlineObject23} request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactsApi
     */
    public sitesSiteIdArtifactsArtifactIdPublishJobIdPost(siteId: string, artifactId: string, jobId: string, request: InlineObject23, options?: any) {
        return ArtifactsApiFp(this.configuration).sitesSiteIdArtifactsArtifactIdPublishJobIdPost(siteId, artifactId, jobId, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set the artifact to public on the Shifter CDN. OR Set the publish date of the artifact
     * @param {string} siteId Site ID
     * @param {string} artifactId Artifact ID
     * @param {InlineObject22} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactsApi
     */
    public sitesSiteIdArtifactsArtifactIdPublishPost(siteId: string, artifactId: string, request?: InlineObject22, options?: any) {
        return ArtifactsApiFp(this.configuration).sitesSiteIdArtifactsArtifactIdPublishPost(siteId, artifactId, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * execute webhook of specific artifact
     * @param {string} siteId 
     * @param {string} artifactId 
     * @param {InlineObject25} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactsApi
     */
    public sitesSiteIdArtifactsArtifactIdWebhookRunnerPost(siteId: string, artifactId: string, request?: InlineObject25, options?: any) {
        return ArtifactsApiFp(this.configuration).sitesSiteIdArtifactsArtifactIdWebhookRunnerPost(siteId, artifactId, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all artifacts.
     * @param {string} siteId Site ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactsApi
     */
    public sitesSiteIdArtifactsGet(siteId: string, options?: any) {
        return ArtifactsApiFp(this.configuration).sitesSiteIdArtifactsGet(siteId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generate artifact.
     * @param {string} siteId Site ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactsApi
     */
    public sitesSiteIdArtifactsPost(siteId: string, options?: any) {
        return ArtifactsApiFp(this.configuration).sitesSiteIdArtifactsPost(siteId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You can get the process of generating
     * @param {string} siteId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactsApi
     */
    public sitesSiteIdCheckGeneratorProcessGet(siteId: string, options?: any) {
        return ArtifactsApiFp(this.configuration).sitesSiteIdCheckGeneratorProcessGet(siteId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BillingApi - axios parameter creator
 * @export
 */
export const BillingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Update payment method
         * @param {InlineObject14} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingPost: async (request: InlineObject14, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('billingPost', 'request', request)
            const localVarPath = `/billing`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get available plans
         * @param {'all' | 'month' | 'year'} [interval] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingsPlansGet: async (interval?: 'all' | 'month' | 'year', options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/billings/plans`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all subscriptions in the current shifter account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingsSubscriptionsGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/billings/subscriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a subscription.
         * @param {InlineObject12} plan 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingsSubscriptionsPost: async (plan: InlineObject12, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'plan' is not null or undefined
            assertParamExists('billingsSubscriptionsPost', 'plan', plan)
            const localVarPath = `/billings/subscriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(plan, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Getting subscription status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingsSubscriptionsStatusGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/billings/subscriptions/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a subscription
         * @param {string} subscriptionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingsSubscriptionsSubscriptionIdDelete: async (subscriptionId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('billingsSubscriptionsSubscriptionIdDelete', 'subscriptionId', subscriptionId)
            const localVarPath = `/billings/subscriptions/{subscription_id}`
                .replace(`{${"subscription_id"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a subscription. Calling this API is allowed to site owner or Administrator members
         * @param {string} subscriptionId Subscription id which update
         * @param {InlineObject13} plan 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingsSubscriptionsSubscriptionIdPost: async (subscriptionId: string, plan: InlineObject13, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('billingsSubscriptionsSubscriptionIdPost', 'subscriptionId', subscriptionId)
            // verify required parameter 'plan' is not null or undefined
            assertParamExists('billingsSubscriptionsSubscriptionIdPost', 'plan', plan)
            const localVarPath = `/billings/subscriptions/{subscription_id}`
                .replace(`{${"subscription_id"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(plan, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BillingApi - functional programming interface
 * @export
 */
export const BillingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BillingApiAxiosParamCreator(configuration)
    return {
        /**
         * Update payment method
         * @param {InlineObject14} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async billingPost(request: InlineObject14, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.billingPost(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get available plans
         * @param {'all' | 'month' | 'year'} [interval] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async billingsPlansGet(interval?: 'all' | 'month' | 'year', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PlanGetResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.billingsPlansGet(interval, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List all subscriptions in the current shifter account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async billingsSubscriptionsGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SubscriptionGetResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.billingsSubscriptionsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a subscription.
         * @param {InlineObject12} plan 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async billingsSubscriptionsPost(plan: InlineObject12, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubscriptionCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.billingsSubscriptionsPost(plan, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Getting subscription status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async billingsSubscriptionsStatusGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.billingsSubscriptionsStatusGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a subscription
         * @param {string} subscriptionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async billingsSubscriptionsSubscriptionIdDelete(subscriptionId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.billingsSubscriptionsSubscriptionIdDelete(subscriptionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a subscription. Calling this API is allowed to site owner or Administrator members
         * @param {string} subscriptionId Subscription id which update
         * @param {InlineObject13} plan 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async billingsSubscriptionsSubscriptionIdPost(subscriptionId: string, plan: InlineObject13, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubscriptionUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.billingsSubscriptionsSubscriptionIdPost(subscriptionId, plan, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BillingApi - factory interface
 * @export
 */
export const BillingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BillingApiFp(configuration)
    return {
        /**
         * Update payment method
         * @param {InlineObject14} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingPost(request: InlineObject14, options?: any): AxiosPromise<void> {
            return localVarFp.billingPost(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Get available plans
         * @param {'all' | 'month' | 'year'} [interval] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingsPlansGet(interval?: 'all' | 'month' | 'year', options?: any): AxiosPromise<Array<PlanGetResponse>> {
            return localVarFp.billingsPlansGet(interval, options).then((request) => request(axios, basePath));
        },
        /**
         * List all subscriptions in the current shifter account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingsSubscriptionsGet(options?: any): AxiosPromise<Array<SubscriptionGetResponse>> {
            return localVarFp.billingsSubscriptionsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Create a subscription.
         * @param {InlineObject12} plan 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingsSubscriptionsPost(plan: InlineObject12, options?: any): AxiosPromise<SubscriptionCreateResponse> {
            return localVarFp.billingsSubscriptionsPost(plan, options).then((request) => request(axios, basePath));
        },
        /**
         * Getting subscription status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingsSubscriptionsStatusGet(options?: any): AxiosPromise<object> {
            return localVarFp.billingsSubscriptionsStatusGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a subscription
         * @param {string} subscriptionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingsSubscriptionsSubscriptionIdDelete(subscriptionId: string, options?: any): AxiosPromise<void> {
            return localVarFp.billingsSubscriptionsSubscriptionIdDelete(subscriptionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a subscription. Calling this API is allowed to site owner or Administrator members
         * @param {string} subscriptionId Subscription id which update
         * @param {InlineObject13} plan 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingsSubscriptionsSubscriptionIdPost(subscriptionId: string, plan: InlineObject13, options?: any): AxiosPromise<SubscriptionUpdateResponse> {
            return localVarFp.billingsSubscriptionsSubscriptionIdPost(subscriptionId, plan, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BillingApi - object-oriented interface
 * @export
 * @class BillingApi
 * @extends {BaseAPI}
 */
export class BillingApi extends BaseAPI {
    /**
     * Update payment method
     * @param {InlineObject14} request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public billingPost(request: InlineObject14, options?: any) {
        return BillingApiFp(this.configuration).billingPost(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get available plans
     * @param {'all' | 'month' | 'year'} [interval] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public billingsPlansGet(interval?: 'all' | 'month' | 'year', options?: any) {
        return BillingApiFp(this.configuration).billingsPlansGet(interval, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all subscriptions in the current shifter account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public billingsSubscriptionsGet(options?: any) {
        return BillingApiFp(this.configuration).billingsSubscriptionsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a subscription.
     * @param {InlineObject12} plan 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public billingsSubscriptionsPost(plan: InlineObject12, options?: any) {
        return BillingApiFp(this.configuration).billingsSubscriptionsPost(plan, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Getting subscription status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public billingsSubscriptionsStatusGet(options?: any) {
        return BillingApiFp(this.configuration).billingsSubscriptionsStatusGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a subscription
     * @param {string} subscriptionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public billingsSubscriptionsSubscriptionIdDelete(subscriptionId: string, options?: any) {
        return BillingApiFp(this.configuration).billingsSubscriptionsSubscriptionIdDelete(subscriptionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a subscription. Calling this API is allowed to site owner or Administrator members
     * @param {string} subscriptionId Subscription id which update
     * @param {InlineObject13} plan 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public billingsSubscriptionsSubscriptionIdPost(subscriptionId: string, plan: InlineObject13, options?: any) {
        return BillingApiFp(this.configuration).billingsSubscriptionsSubscriptionIdPost(subscriptionId, plan, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CouponApi - axios parameter creator
 * @export
 */
export const CouponApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get coupon
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        couponGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/coupon`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Register coupon code.
         * @param {string} code Code of coupon
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        couponsCodePost: async (code: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('couponsCodePost', 'code', code)
            const localVarPath = `/coupons/{code}`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CouponApi - functional programming interface
 * @export
 */
export const CouponApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CouponApiAxiosParamCreator(configuration)
    return {
        /**
         * Get coupon
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async couponGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CouponGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.couponGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Register coupon code.
         * @param {string} code Code of coupon
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async couponsCodePost(code: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.couponsCodePost(code, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CouponApi - factory interface
 * @export
 */
export const CouponApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CouponApiFp(configuration)
    return {
        /**
         * Get coupon
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        couponGet(options?: any): AxiosPromise<CouponGetResponse> {
            return localVarFp.couponGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Register coupon code.
         * @param {string} code Code of coupon
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        couponsCodePost(code: string, options?: any): AxiosPromise<void> {
            return localVarFp.couponsCodePost(code, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CouponApi - object-oriented interface
 * @export
 * @class CouponApi
 * @extends {BaseAPI}
 */
export class CouponApi extends BaseAPI {
    /**
     * Get coupon
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponApi
     */
    public couponGet(options?: any) {
        return CouponApiFp(this.configuration).couponGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Register coupon code.
     * @param {string} code Code of coupon
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CouponApi
     */
    public couponsCodePost(code: string, options?: any) {
        return CouponApiFp(this.configuration).couponsCodePost(code, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DomainsReplacedToTheSiteDomainsApi - axios parameter creator
 * @export
 */
export const DomainsReplacedToTheSiteDomainsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Attache your domain to Shifter CDN
         * @param {string} domain 
         * @param {InlineObject30} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsDomainAttachDomainToShifterCdnPost: async (domain: string, request: InlineObject30, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('domainsDomainAttachDomainToShifterCdnPost', 'domain', domain)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('domainsDomainAttachDomainToShifterCdnPost', 'request', request)
            const localVarPath = `/domains/{domain}/attach_domain_to_shifter_cdn`
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete the added domain
         * @param {string} domain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsDomainDelete: async (domain: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('domainsDomainDelete', 'domain', domain)
            const localVarPath = `/domains/{domain}`
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Detach your domain from Shifter CDN
         * @param {string} domain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsDomainDetachDomainFromShifterCdnPost: async (domain: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('domainsDomainDetachDomainFromShifterCdnPost', 'domain', domain)
            const localVarPath = `/domains/{domain}/detach_domain_from_shifter_cdn`
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * You can get the authentication information of the domain registered by the user
         * @param {string} domain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsDomainGet: async (domain: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('domainsDomainGet', 'domain', domain)
            const localVarPath = `/domains/{domain}`
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add your domain
         * @param {string} domain 
         * @param {InlineObject28} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsDomainPost: async (domain: string, request?: InlineObject28, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('domainsDomainPost', 'domain', domain)
            const localVarPath = `/domains/{domain}`
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resend the approval mail of the SSL certificate
         * @param {string} domain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsDomainResendValidationEmailPost: async (domain: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('domainsDomainResendValidationEmailPost', 'domain', domain)
            const localVarPath = `/domains/{domain}/resend_validation_email`
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Select publishing Subject Alternative Name
         * @param {string} domain 
         * @param {InlineObject29} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsDomainSelectionPost: async (domain: string, request: InlineObject29, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('domainsDomainSelectionPost', 'domain', domain)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('domainsDomainSelectionPost', 'request', request)
            const localVarPath = `/domains/{domain}/selection`
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validating domain by CNAME
         * @param {string} domain 
         * @param {InlineObject31} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsDomainValidateOperationDnsPost: async (domain: string, request?: InlineObject31, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('domainsDomainValidateOperationDnsPost', 'domain', domain)
            const localVarPath = `/domains/{domain}/validate_operation/dns`
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get validation status of specified domain
         * @param {string} domain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsDomainValidateOperationDnsValidationGet: async (domain: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('domainsDomainValidateOperationDnsValidationGet', 'domain', domain)
            const localVarPath = `/domains/{domain}/validate_operation/dns/validation`
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Re validating domain by dns
         * @param {string} domain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsDomainValidateOperationDnsValidationPost: async (domain: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('domainsDomainValidateOperationDnsValidationPost', 'domain', domain)
            const localVarPath = `/domains/{domain}/validate_operation/dns/validation`
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validating domain by email
         * @param {string} domain 
         * @param {InlineObject32} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsDomainValidateOperationEmailPost: async (domain: string, request?: InlineObject32, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('domainsDomainValidateOperationEmailPost', 'domain', domain)
            const localVarPath = `/domains/{domain}/validate_operation/email`
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * You can get information of your domains registered in shifter
         * @param {string} [filter] If it is &#x60;sslValid&#x60;, you can only get certified domains
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsGet: async (filter?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/domains`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DomainsReplacedToTheSiteDomainsApi - functional programming interface
 * @export
 */
export const DomainsReplacedToTheSiteDomainsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DomainsReplacedToTheSiteDomainsApiAxiosParamCreator(configuration)
    return {
        /**
         * Attache your domain to Shifter CDN
         * @param {string} domain 
         * @param {InlineObject30} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async domainsDomainAttachDomainToShifterCdnPost(domain: string, request: InlineObject30, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.domainsDomainAttachDomainToShifterCdnPost(domain, request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete the added domain
         * @param {string} domain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async domainsDomainDelete(domain: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.domainsDomainDelete(domain, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Detach your domain from Shifter CDN
         * @param {string} domain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async domainsDomainDetachDomainFromShifterCdnPost(domain: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.domainsDomainDetachDomainFromShifterCdnPost(domain, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * You can get the authentication information of the domain registered by the user
         * @param {string} domain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async domainsDomainGet(domain: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.domainsDomainGet(domain, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add your domain
         * @param {string} domain 
         * @param {InlineObject28} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async domainsDomainPost(domain: string, request?: InlineObject28, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.domainsDomainPost(domain, request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Resend the approval mail of the SSL certificate
         * @param {string} domain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async domainsDomainResendValidationEmailPost(domain: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.domainsDomainResendValidationEmailPost(domain, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Select publishing Subject Alternative Name
         * @param {string} domain 
         * @param {InlineObject29} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async domainsDomainSelectionPost(domain: string, request: InlineObject29, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.domainsDomainSelectionPost(domain, request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Validating domain by CNAME
         * @param {string} domain 
         * @param {InlineObject31} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async domainsDomainValidateOperationDnsPost(domain: string, request?: InlineObject31, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.domainsDomainValidateOperationDnsPost(domain, request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get validation status of specified domain
         * @param {string} domain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async domainsDomainValidateOperationDnsValidationGet(domain: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.domainsDomainValidateOperationDnsValidationGet(domain, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Re validating domain by dns
         * @param {string} domain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async domainsDomainValidateOperationDnsValidationPost(domain: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.domainsDomainValidateOperationDnsValidationPost(domain, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Validating domain by email
         * @param {string} domain 
         * @param {InlineObject32} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async domainsDomainValidateOperationEmailPost(domain: string, request?: InlineObject32, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.domainsDomainValidateOperationEmailPost(domain, request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * You can get information of your domains registered in shifter
         * @param {string} [filter] If it is &#x60;sslValid&#x60;, you can only get certified domains
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async domainsGet(filter?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse20013>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.domainsGet(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DomainsReplacedToTheSiteDomainsApi - factory interface
 * @export
 */
export const DomainsReplacedToTheSiteDomainsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DomainsReplacedToTheSiteDomainsApiFp(configuration)
    return {
        /**
         * Attache your domain to Shifter CDN
         * @param {string} domain 
         * @param {InlineObject30} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsDomainAttachDomainToShifterCdnPost(domain: string, request: InlineObject30, options?: any): AxiosPromise<void> {
            return localVarFp.domainsDomainAttachDomainToShifterCdnPost(domain, request, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete the added domain
         * @param {string} domain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsDomainDelete(domain: string, options?: any): AxiosPromise<void> {
            return localVarFp.domainsDomainDelete(domain, options).then((request) => request(axios, basePath));
        },
        /**
         * Detach your domain from Shifter CDN
         * @param {string} domain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsDomainDetachDomainFromShifterCdnPost(domain: string, options?: any): AxiosPromise<void> {
            return localVarFp.domainsDomainDetachDomainFromShifterCdnPost(domain, options).then((request) => request(axios, basePath));
        },
        /**
         * You can get the authentication information of the domain registered by the user
         * @param {string} domain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsDomainGet(domain: string, options?: any): AxiosPromise<object> {
            return localVarFp.domainsDomainGet(domain, options).then((request) => request(axios, basePath));
        },
        /**
         * Add your domain
         * @param {string} domain 
         * @param {InlineObject28} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsDomainPost(domain: string, request?: InlineObject28, options?: any): AxiosPromise<void> {
            return localVarFp.domainsDomainPost(domain, request, options).then((request) => request(axios, basePath));
        },
        /**
         * Resend the approval mail of the SSL certificate
         * @param {string} domain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsDomainResendValidationEmailPost(domain: string, options?: any): AxiosPromise<void> {
            return localVarFp.domainsDomainResendValidationEmailPost(domain, options).then((request) => request(axios, basePath));
        },
        /**
         * Select publishing Subject Alternative Name
         * @param {string} domain 
         * @param {InlineObject29} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsDomainSelectionPost(domain: string, request: InlineObject29, options?: any): AxiosPromise<void> {
            return localVarFp.domainsDomainSelectionPost(domain, request, options).then((request) => request(axios, basePath));
        },
        /**
         * Validating domain by CNAME
         * @param {string} domain 
         * @param {InlineObject31} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsDomainValidateOperationDnsPost(domain: string, request?: InlineObject31, options?: any): AxiosPromise<void> {
            return localVarFp.domainsDomainValidateOperationDnsPost(domain, request, options).then((request) => request(axios, basePath));
        },
        /**
         * Get validation status of specified domain
         * @param {string} domain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsDomainValidateOperationDnsValidationGet(domain: string, options?: any): AxiosPromise<object> {
            return localVarFp.domainsDomainValidateOperationDnsValidationGet(domain, options).then((request) => request(axios, basePath));
        },
        /**
         * Re validating domain by dns
         * @param {string} domain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsDomainValidateOperationDnsValidationPost(domain: string, options?: any): AxiosPromise<void> {
            return localVarFp.domainsDomainValidateOperationDnsValidationPost(domain, options).then((request) => request(axios, basePath));
        },
        /**
         * Validating domain by email
         * @param {string} domain 
         * @param {InlineObject32} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsDomainValidateOperationEmailPost(domain: string, request?: InlineObject32, options?: any): AxiosPromise<void> {
            return localVarFp.domainsDomainValidateOperationEmailPost(domain, request, options).then((request) => request(axios, basePath));
        },
        /**
         * You can get information of your domains registered in shifter
         * @param {string} [filter] If it is &#x60;sslValid&#x60;, you can only get certified domains
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsGet(filter?: string, options?: any): AxiosPromise<Array<InlineResponse20013>> {
            return localVarFp.domainsGet(filter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DomainsReplacedToTheSiteDomainsApi - object-oriented interface
 * @export
 * @class DomainsReplacedToTheSiteDomainsApi
 * @extends {BaseAPI}
 */
export class DomainsReplacedToTheSiteDomainsApi extends BaseAPI {
    /**
     * Attache your domain to Shifter CDN
     * @param {string} domain 
     * @param {InlineObject30} request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsReplacedToTheSiteDomainsApi
     */
    public domainsDomainAttachDomainToShifterCdnPost(domain: string, request: InlineObject30, options?: any) {
        return DomainsReplacedToTheSiteDomainsApiFp(this.configuration).domainsDomainAttachDomainToShifterCdnPost(domain, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete the added domain
     * @param {string} domain 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsReplacedToTheSiteDomainsApi
     */
    public domainsDomainDelete(domain: string, options?: any) {
        return DomainsReplacedToTheSiteDomainsApiFp(this.configuration).domainsDomainDelete(domain, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Detach your domain from Shifter CDN
     * @param {string} domain 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsReplacedToTheSiteDomainsApi
     */
    public domainsDomainDetachDomainFromShifterCdnPost(domain: string, options?: any) {
        return DomainsReplacedToTheSiteDomainsApiFp(this.configuration).domainsDomainDetachDomainFromShifterCdnPost(domain, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You can get the authentication information of the domain registered by the user
     * @param {string} domain 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsReplacedToTheSiteDomainsApi
     */
    public domainsDomainGet(domain: string, options?: any) {
        return DomainsReplacedToTheSiteDomainsApiFp(this.configuration).domainsDomainGet(domain, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add your domain
     * @param {string} domain 
     * @param {InlineObject28} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsReplacedToTheSiteDomainsApi
     */
    public domainsDomainPost(domain: string, request?: InlineObject28, options?: any) {
        return DomainsReplacedToTheSiteDomainsApiFp(this.configuration).domainsDomainPost(domain, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resend the approval mail of the SSL certificate
     * @param {string} domain 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsReplacedToTheSiteDomainsApi
     */
    public domainsDomainResendValidationEmailPost(domain: string, options?: any) {
        return DomainsReplacedToTheSiteDomainsApiFp(this.configuration).domainsDomainResendValidationEmailPost(domain, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Select publishing Subject Alternative Name
     * @param {string} domain 
     * @param {InlineObject29} request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsReplacedToTheSiteDomainsApi
     */
    public domainsDomainSelectionPost(domain: string, request: InlineObject29, options?: any) {
        return DomainsReplacedToTheSiteDomainsApiFp(this.configuration).domainsDomainSelectionPost(domain, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Validating domain by CNAME
     * @param {string} domain 
     * @param {InlineObject31} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsReplacedToTheSiteDomainsApi
     */
    public domainsDomainValidateOperationDnsPost(domain: string, request?: InlineObject31, options?: any) {
        return DomainsReplacedToTheSiteDomainsApiFp(this.configuration).domainsDomainValidateOperationDnsPost(domain, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get validation status of specified domain
     * @param {string} domain 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsReplacedToTheSiteDomainsApi
     */
    public domainsDomainValidateOperationDnsValidationGet(domain: string, options?: any) {
        return DomainsReplacedToTheSiteDomainsApiFp(this.configuration).domainsDomainValidateOperationDnsValidationGet(domain, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Re validating domain by dns
     * @param {string} domain 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsReplacedToTheSiteDomainsApi
     */
    public domainsDomainValidateOperationDnsValidationPost(domain: string, options?: any) {
        return DomainsReplacedToTheSiteDomainsApiFp(this.configuration).domainsDomainValidateOperationDnsValidationPost(domain, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Validating domain by email
     * @param {string} domain 
     * @param {InlineObject32} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsReplacedToTheSiteDomainsApi
     */
    public domainsDomainValidateOperationEmailPost(domain: string, request?: InlineObject32, options?: any) {
        return DomainsReplacedToTheSiteDomainsApiFp(this.configuration).domainsDomainValidateOperationEmailPost(domain, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You can get information of your domains registered in shifter
     * @param {string} [filter] If it is &#x60;sslValid&#x60;, you can only get certified domains
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsReplacedToTheSiteDomainsApi
     */
    public domainsGet(filter?: string, options?: any) {
        return DomainsReplacedToTheSiteDomainsApiFp(this.configuration).domainsGet(filter, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IntercomApi - axios parameter creator
 * @export
 */
export const IntercomApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get intercom hmac
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        intercomHmacGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/intercom/hmac`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IntercomApi - functional programming interface
 * @export
 */
export const IntercomApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IntercomApiAxiosParamCreator(configuration)
    return {
        /**
         * Get intercom hmac
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async intercomHmacGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.intercomHmacGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IntercomApi - factory interface
 * @export
 */
export const IntercomApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IntercomApiFp(configuration)
    return {
        /**
         * Get intercom hmac
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        intercomHmacGet(options?: any): AxiosPromise<string> {
            return localVarFp.intercomHmacGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IntercomApi - object-oriented interface
 * @export
 * @class IntercomApi
 * @extends {BaseAPI}
 */
export class IntercomApi extends BaseAPI {
    /**
     * Get intercom hmac
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntercomApi
     */
    public intercomHmacGet(options?: any) {
        return IntercomApiFp(this.configuration).intercomHmacGet(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LoginApi - axios parameter creator
 * @export
 */
export const LoginApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Login to the Shifter. username and password are required. Return AccessToken and RefreshToken when the request succeeded.
         * @param {LoginPostRequest} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginPost: async (request: LoginPostRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('loginPost', 'request', request)
            const localVarPath = `/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Refresh AccessToken by RefreshToken. Return new AccessToken when request succeeded.
         * @param {InlineObject} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginPut: async (request: InlineObject, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('loginPut', 'request', request)
            const localVarPath = `/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LoginApi - functional programming interface
 * @export
 */
export const LoginApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LoginApiAxiosParamCreator(configuration)
    return {
        /**
         * Login to the Shifter. username and password are required. Return AccessToken and RefreshToken when the request succeeded.
         * @param {LoginPostRequest} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginPost(request: LoginPostRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginPostResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginPost(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Refresh AccessToken by RefreshToken. Return new AccessToken when request succeeded.
         * @param {InlineObject} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginPut(request: InlineObject, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginPut(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LoginApi - factory interface
 * @export
 */
export const LoginApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LoginApiFp(configuration)
    return {
        /**
         * Login to the Shifter. username and password are required. Return AccessToken and RefreshToken when the request succeeded.
         * @param {LoginPostRequest} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginPost(request: LoginPostRequest, options?: any): AxiosPromise<LoginPostResponse> {
            return localVarFp.loginPost(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Refresh AccessToken by RefreshToken. Return new AccessToken when request succeeded.
         * @param {InlineObject} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginPut(request: InlineObject, options?: any): AxiosPromise<object> {
            return localVarFp.loginPut(request, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LoginApi - object-oriented interface
 * @export
 * @class LoginApi
 * @extends {BaseAPI}
 */
export class LoginApi extends BaseAPI {
    /**
     * Login to the Shifter. username and password are required. Return AccessToken and RefreshToken when the request succeeded.
     * @param {LoginPostRequest} request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginApi
     */
    public loginPost(request: LoginPostRequest, options?: any) {
        return LoginApiFp(this.configuration).loginPost(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Refresh AccessToken by RefreshToken. Return new AccessToken when request succeeded.
     * @param {InlineObject} request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginApi
     */
    public loginPut(request: InlineObject, options?: any) {
        return LoginApiFp(this.configuration).loginPut(request, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PlansApi - axios parameter creator
 * @export
 */
export const PlansApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * (Previous Plan) Get all plans. An invited user cannot be accessed this API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        plansGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/plans`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (Previous plan) Get details of plan.
         * @param {'free' | 'personal' | 'business' | 'agency' | 'agency plus'} planName Name of play. Specify free or personal or business or agency or agency plus
         * @param {'annual' | 'monthly'} planType Team of plan. Specify annual or monthly
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        plansPlanNamePlanTypeGet: async (planName: 'free' | 'personal' | 'business' | 'agency' | 'agency plus', planType: 'annual' | 'monthly', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'planName' is not null or undefined
            assertParamExists('plansPlanNamePlanTypeGet', 'planName', planName)
            // verify required parameter 'planType' is not null or undefined
            assertParamExists('plansPlanNamePlanTypeGet', 'planType', planType)
            const localVarPath = `/plans/{plan_name}/{plan_type}`
                .replace(`{${"plan_name"}}`, encodeURIComponent(String(planName)))
                .replace(`{${"plan_type"}}`, encodeURIComponent(String(planType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlansApi - functional programming interface
 * @export
 */
export const PlansApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PlansApiAxiosParamCreator(configuration)
    return {
        /**
         * (Previous Plan) Get all plans. An invited user cannot be accessed this API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async plansGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.plansGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * (Previous plan) Get details of plan.
         * @param {'free' | 'personal' | 'business' | 'agency' | 'agency plus'} planName Name of play. Specify free or personal or business or agency or agency plus
         * @param {'annual' | 'monthly'} planType Team of plan. Specify annual or monthly
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async plansPlanNamePlanTypeGet(planName: 'free' | 'personal' | 'business' | 'agency' | 'agency plus', planType: 'annual' | 'monthly', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PreviousPlanResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.plansPlanNamePlanTypeGet(planName, planType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PlansApi - factory interface
 * @export
 */
export const PlansApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PlansApiFp(configuration)
    return {
        /**
         * (Previous Plan) Get all plans. An invited user cannot be accessed this API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        plansGet(options?: any): AxiosPromise<object> {
            return localVarFp.plansGet(options).then((request) => request(axios, basePath));
        },
        /**
         * (Previous plan) Get details of plan.
         * @param {'free' | 'personal' | 'business' | 'agency' | 'agency plus'} planName Name of play. Specify free or personal or business or agency or agency plus
         * @param {'annual' | 'monthly'} planType Team of plan. Specify annual or monthly
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        plansPlanNamePlanTypeGet(planName: 'free' | 'personal' | 'business' | 'agency' | 'agency plus', planType: 'annual' | 'monthly', options?: any): AxiosPromise<PreviousPlanResponse> {
            return localVarFp.plansPlanNamePlanTypeGet(planName, planType, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PlansApi - object-oriented interface
 * @export
 * @class PlansApi
 * @extends {BaseAPI}
 */
export class PlansApi extends BaseAPI {
    /**
     * (Previous Plan) Get all plans. An invited user cannot be accessed this API.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlansApi
     */
    public plansGet(options?: any) {
        return PlansApiFp(this.configuration).plansGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * (Previous plan) Get details of plan.
     * @param {'free' | 'personal' | 'business' | 'agency' | 'agency plus'} planName Name of play. Specify free or personal or business or agency or agency plus
     * @param {'annual' | 'monthly'} planType Team of plan. Specify annual or monthly
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlansApi
     */
    public plansPlanNamePlanTypeGet(planName: 'free' | 'personal' | 'business' | 'agency' | 'agency plus', planType: 'annual' | 'monthly', options?: any) {
        return PlansApiFp(this.configuration).plansPlanNamePlanTypeGet(planName, planType, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RolesApi - axios parameter creator
 * @export
 */
export const RolesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List team member roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a shifter roles
         * @param {string} name Name of role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesNameGet: async (name: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('rolesNameGet', 'name', name)
            const localVarPath = `/roles/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RolesApi - functional programming interface
 * @export
 */
export const RolesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RolesApiAxiosParamCreator(configuration)
    return {
        /**
         * List team member roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rolesGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RoleGetResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rolesGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a shifter roles
         * @param {string} name Name of role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rolesNameGet(name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rolesNameGet(name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RolesApi - factory interface
 * @export
 */
export const RolesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RolesApiFp(configuration)
    return {
        /**
         * List team member roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesGet(options?: any): AxiosPromise<Array<RoleGetResponse>> {
            return localVarFp.rolesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a shifter roles
         * @param {string} name Name of role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesNameGet(name: string, options?: any): AxiosPromise<RoleGetResponse> {
            return localVarFp.rolesNameGet(name, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RolesApi - object-oriented interface
 * @export
 * @class RolesApi
 * @extends {BaseAPI}
 */
export class RolesApi extends BaseAPI {
    /**
     * List team member roles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public rolesGet(options?: any) {
        return RolesApiFp(this.configuration).rolesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a shifter roles
     * @param {string} name Name of role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public rolesNameGet(name: string, options?: any) {
        return RolesApiFp(this.configuration).rolesNameGet(name, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SiteDomainsApi - axios parameter creator
 * @export
 */
export const SiteDomainsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * attach domain to the Shifter Site
         * @param {string} siteId Site ID
         * @param {string} domain Name of domain which is attached
         * @param {InlineObject9} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdDomainsDomainAttachPost: async (siteId: string, domain: string, request?: InlineObject9, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteId' is not null or undefined
            assertParamExists('sitesSiteIdDomainsDomainAttachPost', 'siteId', siteId)
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('sitesSiteIdDomainsDomainAttachPost', 'domain', domain)
            const localVarPath = `/sites/{site_id}/domains/{domain}/attach`
                .replace(`{${"site_id"}}`, encodeURIComponent(String(siteId)))
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove domain
         * @param {string} siteId Site ID
         * @param {string} domain Name of domain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdDomainsDomainDelete: async (siteId: string, domain: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteId' is not null or undefined
            assertParamExists('sitesSiteIdDomainsDomainDelete', 'siteId', siteId)
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('sitesSiteIdDomainsDomainDelete', 'domain', domain)
            const localVarPath = `/sites/{site_id}/domains/{domain}`
                .replace(`{${"site_id"}}`, encodeURIComponent(String(siteId)))
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * detach the domain from Shifter Site.
         * @param {string} siteId Site ID
         * @param {string} domain Name of domain
         * @param {InlineObject10} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdDomainsDomainDetachPost: async (siteId: string, domain: string, request?: InlineObject10, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteId' is not null or undefined
            assertParamExists('sitesSiteIdDomainsDomainDetachPost', 'siteId', siteId)
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('sitesSiteIdDomainsDomainDetachPost', 'domain', domain)
            const localVarPath = `/sites/{site_id}/domains/{domain}/detach`
                .replace(`{${"site_id"}}`, encodeURIComponent(String(siteId)))
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a domain under specific site
         * @param {string} siteId Site ID
         * @param {string} domain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdDomainsDomainGet: async (siteId: string, domain: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteId' is not null or undefined
            assertParamExists('sitesSiteIdDomainsDomainGet', 'siteId', siteId)
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('sitesSiteIdDomainsDomainGet', 'domain', domain)
            const localVarPath = `/sites/{site_id}/domains/{domain}`
                .replace(`{${"site_id"}}`, encodeURIComponent(String(siteId)))
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * add domain of Site
         * @param {string} siteId Site ID
         * @param {string} domain Name of domain
         * @param {InlineObject8} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdDomainsDomainPost: async (siteId: string, domain: string, request?: InlineObject8, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteId' is not null or undefined
            assertParamExists('sitesSiteIdDomainsDomainPost', 'siteId', siteId)
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('sitesSiteIdDomainsDomainPost', 'domain', domain)
            const localVarPath = `/sites/{site_id}/domains/{domain}`
                .replace(`{${"site_id"}}`, encodeURIComponent(String(siteId)))
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * reset deployment domain
         * @param {string} siteId 
         * @param {string} domain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdDomainsDomainSelectionDelete: async (siteId: string, domain: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteId' is not null or undefined
            assertParamExists('sitesSiteIdDomainsDomainSelectionDelete', 'siteId', siteId)
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('sitesSiteIdDomainsDomainSelectionDelete', 'domain', domain)
            const localVarPath = `/sites/{site_id}/domains/{domain}/selection`
                .replace(`{${"site_id"}}`, encodeURIComponent(String(siteId)))
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * choose deployment domain
         * @param {string} siteId 
         * @param {string} domain 
         * @param {InlineObject11} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdDomainsDomainSelectionPost: async (siteId: string, domain: string, request?: InlineObject11, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteId' is not null or undefined
            assertParamExists('sitesSiteIdDomainsDomainSelectionPost', 'siteId', siteId)
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('sitesSiteIdDomainsDomainSelectionPost', 'domain', domain)
            const localVarPath = `/sites/{site_id}/domains/{domain}/selection`
                .replace(`{${"site_id"}}`, encodeURIComponent(String(siteId)))
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get validation status of domain
         * @param {string} siteId Site ID
         * @param {string} domain Name of domain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdDomainsDomainValidationGet: async (siteId: string, domain: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteId' is not null or undefined
            assertParamExists('sitesSiteIdDomainsDomainValidationGet', 'siteId', siteId)
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('sitesSiteIdDomainsDomainValidationGet', 'domain', domain)
            const localVarPath = `/sites/{site_id}/domains/{domain}/validation`
                .replace(`{${"site_id"}}`, encodeURIComponent(String(siteId)))
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * request(again) domain validation
         * @param {string} siteId Site ID
         * @param {string} domain Name of domain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdDomainsDomainValidationPost: async (siteId: string, domain: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteId' is not null or undefined
            assertParamExists('sitesSiteIdDomainsDomainValidationPost', 'siteId', siteId)
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('sitesSiteIdDomainsDomainValidationPost', 'domain', domain)
            const localVarPath = `/sites/{site_id}/domains/{domain}/validation`
                .replace(`{${"site_id"}}`, encodeURIComponent(String(siteId)))
                .replace(`{${"domain"}}`, encodeURIComponent(String(domain)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * list domains
         * @param {string} siteId Site ID
         * @param {InlineObject7} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdDomainsGet: async (siteId: string, request?: InlineObject7, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteId' is not null or undefined
            assertParamExists('sitesSiteIdDomainsGet', 'siteId', siteId)
            const localVarPath = `/sites/{site_id}/domains`
                .replace(`{${"site_id"}}`, encodeURIComponent(String(siteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SiteDomainsApi - functional programming interface
 * @export
 */
export const SiteDomainsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SiteDomainsApiAxiosParamCreator(configuration)
    return {
        /**
         * attach domain to the Shifter Site
         * @param {string} siteId Site ID
         * @param {string} domain Name of domain which is attached
         * @param {InlineObject9} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitesSiteIdDomainsDomainAttachPost(siteId: string, domain: string, request?: InlineObject9, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitesSiteIdDomainsDomainAttachPost(siteId, domain, request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove domain
         * @param {string} siteId Site ID
         * @param {string} domain Name of domain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitesSiteIdDomainsDomainDelete(siteId: string, domain: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitesSiteIdDomainsDomainDelete(siteId, domain, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * detach the domain from Shifter Site.
         * @param {string} siteId Site ID
         * @param {string} domain Name of domain
         * @param {InlineObject10} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitesSiteIdDomainsDomainDetachPost(siteId: string, domain: string, request?: InlineObject10, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitesSiteIdDomainsDomainDetachPost(siteId, domain, request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a domain under specific site
         * @param {string} siteId Site ID
         * @param {string} domain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitesSiteIdDomainsDomainGet(siteId: string, domain: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DomainGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitesSiteIdDomainsDomainGet(siteId, domain, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * add domain of Site
         * @param {string} siteId Site ID
         * @param {string} domain Name of domain
         * @param {InlineObject8} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitesSiteIdDomainsDomainPost(siteId: string, domain: string, request?: InlineObject8, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitesSiteIdDomainsDomainPost(siteId, domain, request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * reset deployment domain
         * @param {string} siteId 
         * @param {string} domain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitesSiteIdDomainsDomainSelectionDelete(siteId: string, domain: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitesSiteIdDomainsDomainSelectionDelete(siteId, domain, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * choose deployment domain
         * @param {string} siteId 
         * @param {string} domain 
         * @param {InlineObject11} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitesSiteIdDomainsDomainSelectionPost(siteId: string, domain: string, request?: InlineObject11, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitesSiteIdDomainsDomainSelectionPost(siteId, domain, request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get validation status of domain
         * @param {string} siteId Site ID
         * @param {string} domain Name of domain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitesSiteIdDomainsDomainValidationGet(siteId: string, domain: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DomainValidationGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitesSiteIdDomainsDomainValidationGet(siteId, domain, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * request(again) domain validation
         * @param {string} siteId Site ID
         * @param {string} domain Name of domain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitesSiteIdDomainsDomainValidationPost(siteId: string, domain: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitesSiteIdDomainsDomainValidationPost(siteId, domain, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * list domains
         * @param {string} siteId Site ID
         * @param {InlineObject7} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitesSiteIdDomainsGet(siteId: string, request?: InlineObject7, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DomainGetResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitesSiteIdDomainsGet(siteId, request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SiteDomainsApi - factory interface
 * @export
 */
export const SiteDomainsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SiteDomainsApiFp(configuration)
    return {
        /**
         * attach domain to the Shifter Site
         * @param {string} siteId Site ID
         * @param {string} domain Name of domain which is attached
         * @param {InlineObject9} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdDomainsDomainAttachPost(siteId: string, domain: string, request?: InlineObject9, options?: any): AxiosPromise<void> {
            return localVarFp.sitesSiteIdDomainsDomainAttachPost(siteId, domain, request, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove domain
         * @param {string} siteId Site ID
         * @param {string} domain Name of domain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdDomainsDomainDelete(siteId: string, domain: string, options?: any): AxiosPromise<void> {
            return localVarFp.sitesSiteIdDomainsDomainDelete(siteId, domain, options).then((request) => request(axios, basePath));
        },
        /**
         * detach the domain from Shifter Site.
         * @param {string} siteId Site ID
         * @param {string} domain Name of domain
         * @param {InlineObject10} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdDomainsDomainDetachPost(siteId: string, domain: string, request?: InlineObject10, options?: any): AxiosPromise<void> {
            return localVarFp.sitesSiteIdDomainsDomainDetachPost(siteId, domain, request, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a domain under specific site
         * @param {string} siteId Site ID
         * @param {string} domain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdDomainsDomainGet(siteId: string, domain: string, options?: any): AxiosPromise<DomainGetResponse> {
            return localVarFp.sitesSiteIdDomainsDomainGet(siteId, domain, options).then((request) => request(axios, basePath));
        },
        /**
         * add domain of Site
         * @param {string} siteId Site ID
         * @param {string} domain Name of domain
         * @param {InlineObject8} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdDomainsDomainPost(siteId: string, domain: string, request?: InlineObject8, options?: any): AxiosPromise<void> {
            return localVarFp.sitesSiteIdDomainsDomainPost(siteId, domain, request, options).then((request) => request(axios, basePath));
        },
        /**
         * reset deployment domain
         * @param {string} siteId 
         * @param {string} domain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdDomainsDomainSelectionDelete(siteId: string, domain: string, options?: any): AxiosPromise<void> {
            return localVarFp.sitesSiteIdDomainsDomainSelectionDelete(siteId, domain, options).then((request) => request(axios, basePath));
        },
        /**
         * choose deployment domain
         * @param {string} siteId 
         * @param {string} domain 
         * @param {InlineObject11} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdDomainsDomainSelectionPost(siteId: string, domain: string, request?: InlineObject11, options?: any): AxiosPromise<void> {
            return localVarFp.sitesSiteIdDomainsDomainSelectionPost(siteId, domain, request, options).then((request) => request(axios, basePath));
        },
        /**
         * Get validation status of domain
         * @param {string} siteId Site ID
         * @param {string} domain Name of domain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdDomainsDomainValidationGet(siteId: string, domain: string, options?: any): AxiosPromise<DomainValidationGetResponse> {
            return localVarFp.sitesSiteIdDomainsDomainValidationGet(siteId, domain, options).then((request) => request(axios, basePath));
        },
        /**
         * request(again) domain validation
         * @param {string} siteId Site ID
         * @param {string} domain Name of domain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdDomainsDomainValidationPost(siteId: string, domain: string, options?: any): AxiosPromise<void> {
            return localVarFp.sitesSiteIdDomainsDomainValidationPost(siteId, domain, options).then((request) => request(axios, basePath));
        },
        /**
         * list domains
         * @param {string} siteId Site ID
         * @param {InlineObject7} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdDomainsGet(siteId: string, request?: InlineObject7, options?: any): AxiosPromise<Array<DomainGetResponse>> {
            return localVarFp.sitesSiteIdDomainsGet(siteId, request, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SiteDomainsApi - object-oriented interface
 * @export
 * @class SiteDomainsApi
 * @extends {BaseAPI}
 */
export class SiteDomainsApi extends BaseAPI {
    /**
     * attach domain to the Shifter Site
     * @param {string} siteId Site ID
     * @param {string} domain Name of domain which is attached
     * @param {InlineObject9} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteDomainsApi
     */
    public sitesSiteIdDomainsDomainAttachPost(siteId: string, domain: string, request?: InlineObject9, options?: any) {
        return SiteDomainsApiFp(this.configuration).sitesSiteIdDomainsDomainAttachPost(siteId, domain, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove domain
     * @param {string} siteId Site ID
     * @param {string} domain Name of domain
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteDomainsApi
     */
    public sitesSiteIdDomainsDomainDelete(siteId: string, domain: string, options?: any) {
        return SiteDomainsApiFp(this.configuration).sitesSiteIdDomainsDomainDelete(siteId, domain, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * detach the domain from Shifter Site.
     * @param {string} siteId Site ID
     * @param {string} domain Name of domain
     * @param {InlineObject10} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteDomainsApi
     */
    public sitesSiteIdDomainsDomainDetachPost(siteId: string, domain: string, request?: InlineObject10, options?: any) {
        return SiteDomainsApiFp(this.configuration).sitesSiteIdDomainsDomainDetachPost(siteId, domain, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a domain under specific site
     * @param {string} siteId Site ID
     * @param {string} domain 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteDomainsApi
     */
    public sitesSiteIdDomainsDomainGet(siteId: string, domain: string, options?: any) {
        return SiteDomainsApiFp(this.configuration).sitesSiteIdDomainsDomainGet(siteId, domain, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * add domain of Site
     * @param {string} siteId Site ID
     * @param {string} domain Name of domain
     * @param {InlineObject8} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteDomainsApi
     */
    public sitesSiteIdDomainsDomainPost(siteId: string, domain: string, request?: InlineObject8, options?: any) {
        return SiteDomainsApiFp(this.configuration).sitesSiteIdDomainsDomainPost(siteId, domain, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * reset deployment domain
     * @param {string} siteId 
     * @param {string} domain 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteDomainsApi
     */
    public sitesSiteIdDomainsDomainSelectionDelete(siteId: string, domain: string, options?: any) {
        return SiteDomainsApiFp(this.configuration).sitesSiteIdDomainsDomainSelectionDelete(siteId, domain, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * choose deployment domain
     * @param {string} siteId 
     * @param {string} domain 
     * @param {InlineObject11} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteDomainsApi
     */
    public sitesSiteIdDomainsDomainSelectionPost(siteId: string, domain: string, request?: InlineObject11, options?: any) {
        return SiteDomainsApiFp(this.configuration).sitesSiteIdDomainsDomainSelectionPost(siteId, domain, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get validation status of domain
     * @param {string} siteId Site ID
     * @param {string} domain Name of domain
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteDomainsApi
     */
    public sitesSiteIdDomainsDomainValidationGet(siteId: string, domain: string, options?: any) {
        return SiteDomainsApiFp(this.configuration).sitesSiteIdDomainsDomainValidationGet(siteId, domain, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * request(again) domain validation
     * @param {string} siteId Site ID
     * @param {string} domain Name of domain
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteDomainsApi
     */
    public sitesSiteIdDomainsDomainValidationPost(siteId: string, domain: string, options?: any) {
        return SiteDomainsApiFp(this.configuration).sitesSiteIdDomainsDomainValidationPost(siteId, domain, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * list domains
     * @param {string} siteId Site ID
     * @param {InlineObject7} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteDomainsApi
     */
    public sitesSiteIdDomainsGet(siteId: string, request?: InlineObject7, options?: any) {
        return SiteDomainsApiFp(this.configuration).sitesSiteIdDomainsGet(siteId, request, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SiteSettingsApi - axios parameter creator
 * @export
 */
export const SiteSettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Disabling WordPress backups
         * @param {string} siteId Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdBackupDelete: async (siteId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteId' is not null or undefined
            assertParamExists('sitesSiteIdBackupDelete', 'siteId', siteId)
            const localVarPath = `/sites/{site_id}/backup`
                .replace(`{${"site_id"}}`, encodeURIComponent(String(siteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Enabling WordPress backups
         * @param {string} siteId Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdBackupPost: async (siteId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteId' is not null or undefined
            assertParamExists('sitesSiteIdBackupPost', 'siteId', siteId)
            const localVarPath = `/sites/{site_id}/backup`
                .replace(`{${"site_id"}}`, encodeURIComponent(String(siteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Disabling basic authentication
         * @param {string} siteId Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdBasicAuthDelete: async (siteId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteId' is not null or undefined
            assertParamExists('sitesSiteIdBasicAuthDelete', 'siteId', siteId)
            const localVarPath = `/sites/{site_id}/basic_auth`
                .replace(`{${"site_id"}}`, encodeURIComponent(String(siteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Enabling basic authentication
         * @param {string} siteId Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdBasicAuthPost: async (siteId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteId' is not null or undefined
            assertParamExists('sitesSiteIdBasicAuthPost', 'siteId', siteId)
            const localVarPath = `/sites/{site_id}/basic_auth`
                .replace(`{${"site_id"}}`, encodeURIComponent(String(siteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the Shifter CDN status
         * @param {string} siteId Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdCdnStatusGet: async (siteId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteId' is not null or undefined
            assertParamExists('sitesSiteIdCdnStatusGet', 'siteId', siteId)
            const localVarPath = `/sites/{site_id}/cdn_status`
                .replace(`{${"site_id"}}`, encodeURIComponent(String(siteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete destination of access logs
         * @param {string} siteId Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdLogsPathDelete: async (siteId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteId' is not null or undefined
            assertParamExists('sitesSiteIdLogsPathDelete', 'siteId', siteId)
            const localVarPath = `/sites/{site_id}/logs/path`
                .replace(`{${"site_id"}}`, encodeURIComponent(String(siteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * set or update destination of access logs
         * @param {string} siteId Site ID
         * @param {InlineObject6} s3BucketName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdLogsPathPut: async (siteId: string, s3BucketName: InlineObject6, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteId' is not null or undefined
            assertParamExists('sitesSiteIdLogsPathPut', 'siteId', siteId)
            // verify required parameter 's3BucketName' is not null or undefined
            assertParamExists('sitesSiteIdLogsPathPut', 's3BucketName', s3BucketName)
            const localVarPath = `/sites/{site_id}/logs/path`
                .replace(`{${"site_id"}}`, encodeURIComponent(String(siteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(s3BucketName, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Disabling media CDN
         * @param {string} siteId Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdMediaCdnDelete: async (siteId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteId' is not null or undefined
            assertParamExists('sitesSiteIdMediaCdnDelete', 'siteId', siteId)
            const localVarPath = `/sites/{site_id}/media_cdn`
                .replace(`{${"site_id"}}`, encodeURIComponent(String(siteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Enabling media CDN
         * @param {string} siteId Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdMediaCdnPost: async (siteId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteId' is not null or undefined
            assertParamExists('sitesSiteIdMediaCdnPost', 'siteId', siteId)
            const localVarPath = `/sites/{site_id}/media_cdn`
                .replace(`{${"site_id"}}`, encodeURIComponent(String(siteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * remove protection of delete
         * @param {string} siteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdProtectionDelete: async (siteId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteId' is not null or undefined
            assertParamExists('sitesSiteIdProtectionDelete', 'siteId', siteId)
            const localVarPath = `/sites/{site_id}/protection`
                .replace(`{${"site_id"}}`, encodeURIComponent(String(siteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * add protection of delete
         * @param {string} siteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdProtectionPost: async (siteId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteId' is not null or undefined
            assertParamExists('sitesSiteIdProtectionPost', 'siteId', siteId)
            const localVarPath = `/sites/{site_id}/protection`
                .replace(`{${"site_id"}}`, encodeURIComponent(String(siteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update site settings. Updatable attributes are site_name, All in one WP migration configuration, Shifter media cdn configuration, and automatic publish configuration.
         * @param {string} siteId Site ID
         * @param {InlineObject2} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdPut: async (siteId: string, request: InlineObject2, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteId' is not null or undefined
            assertParamExists('sitesSiteIdPut', 'siteId', siteId)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('sitesSiteIdPut', 'request', request)
            const localVarPath = `/sites/{site_id}`
                .replace(`{${"site_id"}}`, encodeURIComponent(String(siteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update your site name
         * @param {string} siteId Site ID
         * @param {InlineObject3} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdSiteNamePut: async (siteId: string, request: InlineObject3, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteId' is not null or undefined
            assertParamExists('sitesSiteIdSiteNamePut', 'siteId', siteId)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('sitesSiteIdSiteNamePut', 'request', request)
            const localVarPath = `/sites/{site_id}/site_name`
                .replace(`{${"site_id"}}`, encodeURIComponent(String(siteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove subdirectory name for publishing
         * @param {string} siteId Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdSiteSubdirDelete: async (siteId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteId' is not null or undefined
            assertParamExists('sitesSiteIdSiteSubdirDelete', 'siteId', siteId)
            const localVarPath = `/sites/{site_id}/site_subdir`
                .replace(`{${"site_id"}}`, encodeURIComponent(String(siteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set subdirectory name for publishing
         * @param {string} siteId Site ID
         * @param {InlineObject5} dirName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdSiteSubdirPut: async (siteId: string, dirName: InlineObject5, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteId' is not null or undefined
            assertParamExists('sitesSiteIdSiteSubdirPut', 'siteId', siteId)
            // verify required parameter 'dirName' is not null or undefined
            assertParamExists('sitesSiteIdSiteSubdirPut', 'dirName', dirName)
            const localVarPath = `/sites/{site_id}/site_subdir`
                .replace(`{${"site_id"}}`, encodeURIComponent(String(siteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dirName, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SiteSettingsApi - functional programming interface
 * @export
 */
export const SiteSettingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SiteSettingsApiAxiosParamCreator(configuration)
    return {
        /**
         * Disabling WordPress backups
         * @param {string} siteId Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitesSiteIdBackupDelete(siteId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitesSiteIdBackupDelete(siteId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Enabling WordPress backups
         * @param {string} siteId Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitesSiteIdBackupPost(siteId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitesSiteIdBackupPost(siteId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Disabling basic authentication
         * @param {string} siteId Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitesSiteIdBasicAuthDelete(siteId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitesSiteIdBasicAuthDelete(siteId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Enabling basic authentication
         * @param {string} siteId Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitesSiteIdBasicAuthPost(siteId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitesSiteIdBasicAuthPost(siteId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the Shifter CDN status
         * @param {string} siteId Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitesSiteIdCdnStatusGet(siteId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CdnStatusGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitesSiteIdCdnStatusGet(siteId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * delete destination of access logs
         * @param {string} siteId Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitesSiteIdLogsPathDelete(siteId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitesSiteIdLogsPathDelete(siteId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * set or update destination of access logs
         * @param {string} siteId Site ID
         * @param {InlineObject6} s3BucketName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitesSiteIdLogsPathPut(siteId: string, s3BucketName: InlineObject6, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitesSiteIdLogsPathPut(siteId, s3BucketName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Disabling media CDN
         * @param {string} siteId Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitesSiteIdMediaCdnDelete(siteId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitesSiteIdMediaCdnDelete(siteId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Enabling media CDN
         * @param {string} siteId Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitesSiteIdMediaCdnPost(siteId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitesSiteIdMediaCdnPost(siteId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * remove protection of delete
         * @param {string} siteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitesSiteIdProtectionDelete(siteId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitesSiteIdProtectionDelete(siteId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * add protection of delete
         * @param {string} siteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitesSiteIdProtectionPost(siteId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitesSiteIdProtectionPost(siteId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * update site settings. Updatable attributes are site_name, All in one WP migration configuration, Shifter media cdn configuration, and automatic publish configuration.
         * @param {string} siteId Site ID
         * @param {InlineObject2} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitesSiteIdPut(siteId: string, request: InlineObject2, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitesSiteIdPut(siteId, request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update your site name
         * @param {string} siteId Site ID
         * @param {InlineObject3} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitesSiteIdSiteNamePut(siteId: string, request: InlineObject3, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitesSiteIdSiteNamePut(siteId, request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Remove subdirectory name for publishing
         * @param {string} siteId Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitesSiteIdSiteSubdirDelete(siteId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitesSiteIdSiteSubdirDelete(siteId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Set subdirectory name for publishing
         * @param {string} siteId Site ID
         * @param {InlineObject5} dirName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitesSiteIdSiteSubdirPut(siteId: string, dirName: InlineObject5, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitesSiteIdSiteSubdirPut(siteId, dirName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SiteSettingsApi - factory interface
 * @export
 */
export const SiteSettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SiteSettingsApiFp(configuration)
    return {
        /**
         * Disabling WordPress backups
         * @param {string} siteId Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdBackupDelete(siteId: string, options?: any): AxiosPromise<void> {
            return localVarFp.sitesSiteIdBackupDelete(siteId, options).then((request) => request(axios, basePath));
        },
        /**
         * Enabling WordPress backups
         * @param {string} siteId Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdBackupPost(siteId: string, options?: any): AxiosPromise<void> {
            return localVarFp.sitesSiteIdBackupPost(siteId, options).then((request) => request(axios, basePath));
        },
        /**
         * Disabling basic authentication
         * @param {string} siteId Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdBasicAuthDelete(siteId: string, options?: any): AxiosPromise<void> {
            return localVarFp.sitesSiteIdBasicAuthDelete(siteId, options).then((request) => request(axios, basePath));
        },
        /**
         * Enabling basic authentication
         * @param {string} siteId Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdBasicAuthPost(siteId: string, options?: any): AxiosPromise<void> {
            return localVarFp.sitesSiteIdBasicAuthPost(siteId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the Shifter CDN status
         * @param {string} siteId Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdCdnStatusGet(siteId: string, options?: any): AxiosPromise<CdnStatusGetResponse> {
            return localVarFp.sitesSiteIdCdnStatusGet(siteId, options).then((request) => request(axios, basePath));
        },
        /**
         * delete destination of access logs
         * @param {string} siteId Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdLogsPathDelete(siteId: string, options?: any): AxiosPromise<void> {
            return localVarFp.sitesSiteIdLogsPathDelete(siteId, options).then((request) => request(axios, basePath));
        },
        /**
         * set or update destination of access logs
         * @param {string} siteId Site ID
         * @param {InlineObject6} s3BucketName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdLogsPathPut(siteId: string, s3BucketName: InlineObject6, options?: any): AxiosPromise<void> {
            return localVarFp.sitesSiteIdLogsPathPut(siteId, s3BucketName, options).then((request) => request(axios, basePath));
        },
        /**
         * Disabling media CDN
         * @param {string} siteId Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdMediaCdnDelete(siteId: string, options?: any): AxiosPromise<void> {
            return localVarFp.sitesSiteIdMediaCdnDelete(siteId, options).then((request) => request(axios, basePath));
        },
        /**
         * Enabling media CDN
         * @param {string} siteId Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdMediaCdnPost(siteId: string, options?: any): AxiosPromise<void> {
            return localVarFp.sitesSiteIdMediaCdnPost(siteId, options).then((request) => request(axios, basePath));
        },
        /**
         * remove protection of delete
         * @param {string} siteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdProtectionDelete(siteId: string, options?: any): AxiosPromise<void> {
            return localVarFp.sitesSiteIdProtectionDelete(siteId, options).then((request) => request(axios, basePath));
        },
        /**
         * add protection of delete
         * @param {string} siteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdProtectionPost(siteId: string, options?: any): AxiosPromise<void> {
            return localVarFp.sitesSiteIdProtectionPost(siteId, options).then((request) => request(axios, basePath));
        },
        /**
         * update site settings. Updatable attributes are site_name, All in one WP migration configuration, Shifter media cdn configuration, and automatic publish configuration.
         * @param {string} siteId Site ID
         * @param {InlineObject2} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdPut(siteId: string, request: InlineObject2, options?: any): AxiosPromise<void> {
            return localVarFp.sitesSiteIdPut(siteId, request, options).then((request) => request(axios, basePath));
        },
        /**
         * Update your site name
         * @param {string} siteId Site ID
         * @param {InlineObject3} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdSiteNamePut(siteId: string, request: InlineObject3, options?: any): AxiosPromise<void> {
            return localVarFp.sitesSiteIdSiteNamePut(siteId, request, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove subdirectory name for publishing
         * @param {string} siteId Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdSiteSubdirDelete(siteId: string, options?: any): AxiosPromise<void> {
            return localVarFp.sitesSiteIdSiteSubdirDelete(siteId, options).then((request) => request(axios, basePath));
        },
        /**
         * Set subdirectory name for publishing
         * @param {string} siteId Site ID
         * @param {InlineObject5} dirName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdSiteSubdirPut(siteId: string, dirName: InlineObject5, options?: any): AxiosPromise<void> {
            return localVarFp.sitesSiteIdSiteSubdirPut(siteId, dirName, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SiteSettingsApi - object-oriented interface
 * @export
 * @class SiteSettingsApi
 * @extends {BaseAPI}
 */
export class SiteSettingsApi extends BaseAPI {
    /**
     * Disabling WordPress backups
     * @param {string} siteId Site ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteSettingsApi
     */
    public sitesSiteIdBackupDelete(siteId: string, options?: any) {
        return SiteSettingsApiFp(this.configuration).sitesSiteIdBackupDelete(siteId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Enabling WordPress backups
     * @param {string} siteId Site ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteSettingsApi
     */
    public sitesSiteIdBackupPost(siteId: string, options?: any) {
        return SiteSettingsApiFp(this.configuration).sitesSiteIdBackupPost(siteId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Disabling basic authentication
     * @param {string} siteId Site ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteSettingsApi
     */
    public sitesSiteIdBasicAuthDelete(siteId: string, options?: any) {
        return SiteSettingsApiFp(this.configuration).sitesSiteIdBasicAuthDelete(siteId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Enabling basic authentication
     * @param {string} siteId Site ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteSettingsApi
     */
    public sitesSiteIdBasicAuthPost(siteId: string, options?: any) {
        return SiteSettingsApiFp(this.configuration).sitesSiteIdBasicAuthPost(siteId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the Shifter CDN status
     * @param {string} siteId Site ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteSettingsApi
     */
    public sitesSiteIdCdnStatusGet(siteId: string, options?: any) {
        return SiteSettingsApiFp(this.configuration).sitesSiteIdCdnStatusGet(siteId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * delete destination of access logs
     * @param {string} siteId Site ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteSettingsApi
     */
    public sitesSiteIdLogsPathDelete(siteId: string, options?: any) {
        return SiteSettingsApiFp(this.configuration).sitesSiteIdLogsPathDelete(siteId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * set or update destination of access logs
     * @param {string} siteId Site ID
     * @param {InlineObject6} s3BucketName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteSettingsApi
     */
    public sitesSiteIdLogsPathPut(siteId: string, s3BucketName: InlineObject6, options?: any) {
        return SiteSettingsApiFp(this.configuration).sitesSiteIdLogsPathPut(siteId, s3BucketName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Disabling media CDN
     * @param {string} siteId Site ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteSettingsApi
     */
    public sitesSiteIdMediaCdnDelete(siteId: string, options?: any) {
        return SiteSettingsApiFp(this.configuration).sitesSiteIdMediaCdnDelete(siteId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Enabling media CDN
     * @param {string} siteId Site ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteSettingsApi
     */
    public sitesSiteIdMediaCdnPost(siteId: string, options?: any) {
        return SiteSettingsApiFp(this.configuration).sitesSiteIdMediaCdnPost(siteId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * remove protection of delete
     * @param {string} siteId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteSettingsApi
     */
    public sitesSiteIdProtectionDelete(siteId: string, options?: any) {
        return SiteSettingsApiFp(this.configuration).sitesSiteIdProtectionDelete(siteId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * add protection of delete
     * @param {string} siteId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteSettingsApi
     */
    public sitesSiteIdProtectionPost(siteId: string, options?: any) {
        return SiteSettingsApiFp(this.configuration).sitesSiteIdProtectionPost(siteId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update site settings. Updatable attributes are site_name, All in one WP migration configuration, Shifter media cdn configuration, and automatic publish configuration.
     * @param {string} siteId Site ID
     * @param {InlineObject2} request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteSettingsApi
     */
    public sitesSiteIdPut(siteId: string, request: InlineObject2, options?: any) {
        return SiteSettingsApiFp(this.configuration).sitesSiteIdPut(siteId, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update your site name
     * @param {string} siteId Site ID
     * @param {InlineObject3} request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteSettingsApi
     */
    public sitesSiteIdSiteNamePut(siteId: string, request: InlineObject3, options?: any) {
        return SiteSettingsApiFp(this.configuration).sitesSiteIdSiteNamePut(siteId, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove subdirectory name for publishing
     * @param {string} siteId Site ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteSettingsApi
     */
    public sitesSiteIdSiteSubdirDelete(siteId: string, options?: any) {
        return SiteSettingsApiFp(this.configuration).sitesSiteIdSiteSubdirDelete(siteId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Set subdirectory name for publishing
     * @param {string} siteId Site ID
     * @param {InlineObject5} dirName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SiteSettingsApi
     */
    public sitesSiteIdSiteSubdirPut(siteId: string, dirName: InlineObject5, options?: any) {
        return SiteSettingsApiFp(this.configuration).sitesSiteIdSiteSubdirPut(siteId, dirName, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SitesApi - axios parameter creator
 * @export
 */
export const SitesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List sites user can reach. In these sites, the sites that includes in the list are owner\'s one and member\'s one.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/sites`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the information of your sites
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesMysitesGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/sites/mysites`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new site. The body parameter site_name or project_name is required. To associate subscription set plan_id and subscription_id.
         * @param {InlineObject1} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesPost: async (request: InlineObject1, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('sitesPost', 'request', request)
            const localVarPath = `/sites`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Disable the Pay as you go of Data Transfer Usage
         * @param {string} siteId Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdCdnPaygDelete: async (siteId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteId' is not null or undefined
            assertParamExists('sitesSiteIdCdnPaygDelete', 'siteId', siteId)
            const localVarPath = `/sites/{site_id}/cdn/payg`
                .replace(`{${"site_id"}}`, encodeURIComponent(String(siteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Enable the Pay as you go of Data Transfer Usage
         * @param {string} siteId Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdCdnPaygPost: async (siteId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteId' is not null or undefined
            assertParamExists('sitesSiteIdCdnPaygPost', 'siteId', siteId)
            const localVarPath = `/sites/{site_id}/cdn/payg`
                .replace(`{${"site_id"}}`, encodeURIComponent(String(siteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete your site
         * @param {string} siteId Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdDelete: async (siteId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteId' is not null or undefined
            assertParamExists('sitesSiteIdDelete', 'siteId', siteId)
            const localVarPath = `/sites/{site_id}`
                .replace(`{${"site_id"}}`, encodeURIComponent(String(siteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * You can get the history of generating in the site
         * @param {string} siteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdGenerateHistoryGet: async (siteId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteId' is not null or undefined
            assertParamExists('sitesSiteIdGenerateHistoryGet', 'siteId', siteId)
            const localVarPath = `/sites/{site_id}/generate_history`
                .replace(`{${"site_id"}}`, encodeURIComponent(String(siteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get your site information
         * @param {string} siteId Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdGet: async (siteId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteId' is not null or undefined
            assertParamExists('sitesSiteIdGet', 'siteId', siteId)
            const localVarPath = `/sites/{site_id}`
                .replace(`{${"site_id"}}`, encodeURIComponent(String(siteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * delete notification email for the site event
         * @param {string} siteId 
         * @param {Array<string>} [addresses] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdNotificationEmailDelete: async (siteId: string, addresses?: Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteId' is not null or undefined
            assertParamExists('sitesSiteIdNotificationEmailDelete', 'siteId', siteId)
            const localVarPath = `/sites/{site_id}/notification/email`
                .replace(`{${"site_id"}}`, encodeURIComponent(String(siteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addresses, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get notification email for the site event
         * @param {string} siteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdNotificationEmailGet: async (siteId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteId' is not null or undefined
            assertParamExists('sitesSiteIdNotificationEmailGet', 'siteId', siteId)
            const localVarPath = `/sites/{site_id}/notification/email`
                .replace(`{${"site_id"}}`, encodeURIComponent(String(siteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update notification email for the site event
         * @param {string} siteId 
         * @param {Array<string>} [addresses] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdNotificationEmailPut: async (siteId: string, addresses?: Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteId' is not null or undefined
            assertParamExists('sitesSiteIdNotificationEmailPut', 'siteId', siteId)
            const localVarPath = `/sites/{site_id}/notification/email`
                .replace(`{${"site_id"}}`, encodeURIComponent(String(siteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addresses, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * clear public content
         * @param {string} siteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdPublicContentDelete: async (siteId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteId' is not null or undefined
            assertParamExists('sitesSiteIdPublicContentDelete', 'siteId', siteId)
            const localVarPath = `/sites/{site_id}/public_content`
                .replace(`{${"site_id"}}`, encodeURIComponent(String(siteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * You can get the transfer amount for Shifter CDN
         * @param {string} siteId 
         * @param {number} [startMonth] Start month of the period you want to acquire the transfer amount ex: 201605
         * @param {number} [range] Period for acquiring it (the month) ex: 12
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdShifterCdnTransferAmountGet: async (siteId: string, startMonth?: number, range?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteId' is not null or undefined
            assertParamExists('sitesSiteIdShifterCdnTransferAmountGet', 'siteId', siteId)
            const localVarPath = `/sites/{site_id}/shifter_cdn_transfer_amount`
                .replace(`{${"site_id"}}`, encodeURIComponent(String(siteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (startMonth !== undefined) {
                localVarQueryParameter['start_month'] = startMonth;
            }

            if (range !== undefined) {
                localVarQueryParameter['range'] = range;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Migrate from previous plan to Shifter current plan
         * @param {string} siteId Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdSubscriptionMigratePost: async (siteId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteId' is not null or undefined
            assertParamExists('sitesSiteIdSubscriptionMigratePost', 'siteId', siteId)
            const localVarPath = `/sites/{site_id}/subscription/migrate`
                .replace(`{${"site_id"}}`, encodeURIComponent(String(siteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * list team Id which the site belongs to
         * @param {string} siteId Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdTeamsGet: async (siteId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteId' is not null or undefined
            assertParamExists('sitesSiteIdTeamsGet', 'siteId', siteId)
            const localVarPath = `/sites/{site_id}/teams`
                .replace(`{${"site_id"}}`, encodeURIComponent(String(siteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SitesApi - functional programming interface
 * @export
 */
export const SitesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SitesApiAxiosParamCreator(configuration)
    return {
        /**
         * List sites user can reach. In these sites, the sites that includes in the list are owner\'s one and member\'s one.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitesGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SiteResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitesGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List the information of your sites
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitesMysitesGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SiteResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitesMysitesGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new site. The body parameter site_name or project_name is required. To associate subscription set plan_id and subscription_id.
         * @param {InlineObject1} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitesPost(request: InlineObject1, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SiteCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitesPost(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Disable the Pay as you go of Data Transfer Usage
         * @param {string} siteId Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitesSiteIdCdnPaygDelete(siteId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitesSiteIdCdnPaygDelete(siteId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Enable the Pay as you go of Data Transfer Usage
         * @param {string} siteId Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitesSiteIdCdnPaygPost(siteId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitesSiteIdCdnPaygPost(siteId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete your site
         * @param {string} siteId Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitesSiteIdDelete(siteId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitesSiteIdDelete(siteId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * You can get the history of generating in the site
         * @param {string} siteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitesSiteIdGenerateHistoryGet(siteId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse20010>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitesSiteIdGenerateHistoryGet(siteId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get your site information
         * @param {string} siteId Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitesSiteIdGet(siteId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SiteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitesSiteIdGet(siteId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * delete notification email for the site event
         * @param {string} siteId 
         * @param {Array<string>} [addresses] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitesSiteIdNotificationEmailDelete(siteId: string, addresses?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitesSiteIdNotificationEmailDelete(siteId, addresses, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * get notification email for the site event
         * @param {string} siteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitesSiteIdNotificationEmailGet(siteId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitesSiteIdNotificationEmailGet(siteId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * update notification email for the site event
         * @param {string} siteId 
         * @param {Array<string>} [addresses] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitesSiteIdNotificationEmailPut(siteId: string, addresses?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitesSiteIdNotificationEmailPut(siteId, addresses, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * clear public content
         * @param {string} siteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitesSiteIdPublicContentDelete(siteId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitesSiteIdPublicContentDelete(siteId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * You can get the transfer amount for Shifter CDN
         * @param {string} siteId 
         * @param {number} [startMonth] Start month of the period you want to acquire the transfer amount ex: 201605
         * @param {number} [range] Period for acquiring it (the month) ex: 12
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitesSiteIdShifterCdnTransferAmountGet(siteId: string, startMonth?: number, range?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse20011>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitesSiteIdShifterCdnTransferAmountGet(siteId, startMonth, range, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Migrate from previous plan to Shifter current plan
         * @param {string} siteId Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitesSiteIdSubscriptionMigratePost(siteId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitesSiteIdSubscriptionMigratePost(siteId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * list team Id which the site belongs to
         * @param {string} siteId Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitesSiteIdTeamsGet(siteId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitesSiteIdTeamsGet(siteId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SitesApi - factory interface
 * @export
 */
export const SitesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SitesApiFp(configuration)
    return {
        /**
         * List sites user can reach. In these sites, the sites that includes in the list are owner\'s one and member\'s one.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesGet(options?: any): AxiosPromise<Array<SiteResponse>> {
            return localVarFp.sitesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * List the information of your sites
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesMysitesGet(options?: any): AxiosPromise<Array<SiteResponse>> {
            return localVarFp.sitesMysitesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new site. The body parameter site_name or project_name is required. To associate subscription set plan_id and subscription_id.
         * @param {InlineObject1} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesPost(request: InlineObject1, options?: any): AxiosPromise<SiteCreateResponse> {
            return localVarFp.sitesPost(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Disable the Pay as you go of Data Transfer Usage
         * @param {string} siteId Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdCdnPaygDelete(siteId: string, options?: any): AxiosPromise<void> {
            return localVarFp.sitesSiteIdCdnPaygDelete(siteId, options).then((request) => request(axios, basePath));
        },
        /**
         * Enable the Pay as you go of Data Transfer Usage
         * @param {string} siteId Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdCdnPaygPost(siteId: string, options?: any): AxiosPromise<void> {
            return localVarFp.sitesSiteIdCdnPaygPost(siteId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete your site
         * @param {string} siteId Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdDelete(siteId: string, options?: any): AxiosPromise<void> {
            return localVarFp.sitesSiteIdDelete(siteId, options).then((request) => request(axios, basePath));
        },
        /**
         * You can get the history of generating in the site
         * @param {string} siteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdGenerateHistoryGet(siteId: string, options?: any): AxiosPromise<Array<InlineResponse20010>> {
            return localVarFp.sitesSiteIdGenerateHistoryGet(siteId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get your site information
         * @param {string} siteId Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdGet(siteId: string, options?: any): AxiosPromise<SiteResponse> {
            return localVarFp.sitesSiteIdGet(siteId, options).then((request) => request(axios, basePath));
        },
        /**
         * delete notification email for the site event
         * @param {string} siteId 
         * @param {Array<string>} [addresses] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdNotificationEmailDelete(siteId: string, addresses?: Array<string>, options?: any): AxiosPromise<void> {
            return localVarFp.sitesSiteIdNotificationEmailDelete(siteId, addresses, options).then((request) => request(axios, basePath));
        },
        /**
         * get notification email for the site event
         * @param {string} siteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdNotificationEmailGet(siteId: string, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.sitesSiteIdNotificationEmailGet(siteId, options).then((request) => request(axios, basePath));
        },
        /**
         * update notification email for the site event
         * @param {string} siteId 
         * @param {Array<string>} [addresses] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdNotificationEmailPut(siteId: string, addresses?: Array<string>, options?: any): AxiosPromise<void> {
            return localVarFp.sitesSiteIdNotificationEmailPut(siteId, addresses, options).then((request) => request(axios, basePath));
        },
        /**
         * clear public content
         * @param {string} siteId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdPublicContentDelete(siteId: string, options?: any): AxiosPromise<void> {
            return localVarFp.sitesSiteIdPublicContentDelete(siteId, options).then((request) => request(axios, basePath));
        },
        /**
         * You can get the transfer amount for Shifter CDN
         * @param {string} siteId 
         * @param {number} [startMonth] Start month of the period you want to acquire the transfer amount ex: 201605
         * @param {number} [range] Period for acquiring it (the month) ex: 12
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdShifterCdnTransferAmountGet(siteId: string, startMonth?: number, range?: number, options?: any): AxiosPromise<Array<InlineResponse20011>> {
            return localVarFp.sitesSiteIdShifterCdnTransferAmountGet(siteId, startMonth, range, options).then((request) => request(axios, basePath));
        },
        /**
         * Migrate from previous plan to Shifter current plan
         * @param {string} siteId Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdSubscriptionMigratePost(siteId: string, options?: any): AxiosPromise<string> {
            return localVarFp.sitesSiteIdSubscriptionMigratePost(siteId, options).then((request) => request(axios, basePath));
        },
        /**
         * list team Id which the site belongs to
         * @param {string} siteId Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdTeamsGet(siteId: string, options?: any): AxiosPromise<object> {
            return localVarFp.sitesSiteIdTeamsGet(siteId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SitesApi - object-oriented interface
 * @export
 * @class SitesApi
 * @extends {BaseAPI}
 */
export class SitesApi extends BaseAPI {
    /**
     * List sites user can reach. In these sites, the sites that includes in the list are owner\'s one and member\'s one.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SitesApi
     */
    public sitesGet(options?: any) {
        return SitesApiFp(this.configuration).sitesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the information of your sites
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SitesApi
     */
    public sitesMysitesGet(options?: any) {
        return SitesApiFp(this.configuration).sitesMysitesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new site. The body parameter site_name or project_name is required. To associate subscription set plan_id and subscription_id.
     * @param {InlineObject1} request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SitesApi
     */
    public sitesPost(request: InlineObject1, options?: any) {
        return SitesApiFp(this.configuration).sitesPost(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Disable the Pay as you go of Data Transfer Usage
     * @param {string} siteId Site ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SitesApi
     */
    public sitesSiteIdCdnPaygDelete(siteId: string, options?: any) {
        return SitesApiFp(this.configuration).sitesSiteIdCdnPaygDelete(siteId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Enable the Pay as you go of Data Transfer Usage
     * @param {string} siteId Site ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SitesApi
     */
    public sitesSiteIdCdnPaygPost(siteId: string, options?: any) {
        return SitesApiFp(this.configuration).sitesSiteIdCdnPaygPost(siteId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete your site
     * @param {string} siteId Site ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SitesApi
     */
    public sitesSiteIdDelete(siteId: string, options?: any) {
        return SitesApiFp(this.configuration).sitesSiteIdDelete(siteId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You can get the history of generating in the site
     * @param {string} siteId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SitesApi
     */
    public sitesSiteIdGenerateHistoryGet(siteId: string, options?: any) {
        return SitesApiFp(this.configuration).sitesSiteIdGenerateHistoryGet(siteId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get your site information
     * @param {string} siteId Site ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SitesApi
     */
    public sitesSiteIdGet(siteId: string, options?: any) {
        return SitesApiFp(this.configuration).sitesSiteIdGet(siteId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * delete notification email for the site event
     * @param {string} siteId 
     * @param {Array<string>} [addresses] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SitesApi
     */
    public sitesSiteIdNotificationEmailDelete(siteId: string, addresses?: Array<string>, options?: any) {
        return SitesApiFp(this.configuration).sitesSiteIdNotificationEmailDelete(siteId, addresses, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get notification email for the site event
     * @param {string} siteId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SitesApi
     */
    public sitesSiteIdNotificationEmailGet(siteId: string, options?: any) {
        return SitesApiFp(this.configuration).sitesSiteIdNotificationEmailGet(siteId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update notification email for the site event
     * @param {string} siteId 
     * @param {Array<string>} [addresses] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SitesApi
     */
    public sitesSiteIdNotificationEmailPut(siteId: string, addresses?: Array<string>, options?: any) {
        return SitesApiFp(this.configuration).sitesSiteIdNotificationEmailPut(siteId, addresses, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * clear public content
     * @param {string} siteId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SitesApi
     */
    public sitesSiteIdPublicContentDelete(siteId: string, options?: any) {
        return SitesApiFp(this.configuration).sitesSiteIdPublicContentDelete(siteId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * You can get the transfer amount for Shifter CDN
     * @param {string} siteId 
     * @param {number} [startMonth] Start month of the period you want to acquire the transfer amount ex: 201605
     * @param {number} [range] Period for acquiring it (the month) ex: 12
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SitesApi
     */
    public sitesSiteIdShifterCdnTransferAmountGet(siteId: string, startMonth?: number, range?: number, options?: any) {
        return SitesApiFp(this.configuration).sitesSiteIdShifterCdnTransferAmountGet(siteId, startMonth, range, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Migrate from previous plan to Shifter current plan
     * @param {string} siteId Site ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SitesApi
     */
    public sitesSiteIdSubscriptionMigratePost(siteId: string, options?: any) {
        return SitesApiFp(this.configuration).sitesSiteIdSubscriptionMigratePost(siteId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * list team Id which the site belongs to
     * @param {string} siteId Site ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SitesApi
     */
    public sitesSiteIdTeamsGet(siteId: string, options?: any) {
        return SitesApiFp(this.configuration).sitesSiteIdTeamsGet(siteId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StatisticsApi - axios parameter creator
 * @export
 */
export const StatisticsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * (Previous Plan) Monthly Statistics of Site usage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statisticsUsageSummaryGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/statistics/usage_summary`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StatisticsApi - functional programming interface
 * @export
 */
export const StatisticsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StatisticsApiAxiosParamCreator(configuration)
    return {
        /**
         * (Previous Plan) Monthly Statistics of Site usage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statisticsUsageSummaryGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsageSummaryGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.statisticsUsageSummaryGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StatisticsApi - factory interface
 * @export
 */
export const StatisticsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StatisticsApiFp(configuration)
    return {
        /**
         * (Previous Plan) Monthly Statistics of Site usage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statisticsUsageSummaryGet(options?: any): AxiosPromise<UsageSummaryGetResponse> {
            return localVarFp.statisticsUsageSummaryGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StatisticsApi - object-oriented interface
 * @export
 * @class StatisticsApi
 * @extends {BaseAPI}
 */
export class StatisticsApi extends BaseAPI {
    /**
     * (Previous Plan) Monthly Statistics of Site usage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatisticsApi
     */
    public statisticsUsageSummaryGet(options?: any) {
        return StatisticsApiFp(this.configuration).statisticsUsageSummaryGet(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StatusApi - axios parameter creator
 * @export
 */
export const StatusApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get the status of your account and Shifter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get role specific team of logged in user
         * @param {string} teamId Team ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusTeamsTeamIdRoleGet: async (teamId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('statusTeamsTeamIdRoleGet', 'teamId', teamId)
            const localVarPath = `/status/teams/{team_id}/role`
                .replace(`{${"team_id"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StatusApi - functional programming interface
 * @export
 */
export const StatusApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StatusApiAxiosParamCreator(configuration)
    return {
        /**
         * Get the status of your account and Shifter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statusGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatusGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.statusGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get role specific team of logged in user
         * @param {string} teamId Team ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statusTeamsTeamIdRoleGet(teamId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2009>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.statusTeamsTeamIdRoleGet(teamId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StatusApi - factory interface
 * @export
 */
export const StatusApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StatusApiFp(configuration)
    return {
        /**
         * Get the status of your account and Shifter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusGet(options?: any): AxiosPromise<StatusGetResponse> {
            return localVarFp.statusGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Get role specific team of logged in user
         * @param {string} teamId Team ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusTeamsTeamIdRoleGet(teamId: string, options?: any): AxiosPromise<InlineResponse2009> {
            return localVarFp.statusTeamsTeamIdRoleGet(teamId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StatusApi - object-oriented interface
 * @export
 * @class StatusApi
 * @extends {BaseAPI}
 */
export class StatusApi extends BaseAPI {
    /**
     * Get the status of your account and Shifter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatusApi
     */
    public statusGet(options?: any) {
        return StatusApiFp(this.configuration).statusGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get role specific team of logged in user
     * @param {string} teamId Team ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatusApi
     */
    public statusTeamsTeamIdRoleGet(teamId: string, options?: any) {
        return StatusApiFp(this.configuration).statusTeamsTeamIdRoleGet(teamId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TeamsApi - axios parameter creator
 * @export
 */
export const TeamsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List teams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/teams`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List teams which member belongs into
         * @param {string} memberName Member\&#39;s name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsMembersMemberNameTeamsGet: async (memberName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'memberName' is not null or undefined
            assertParamExists('teamsMembersMemberNameTeamsGet', 'memberName', memberName)
            const localVarPath = `/teams/members/{member_name}/teams`
                .replace(`{${"member_name"}}`, encodeURIComponent(String(memberName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a team
         * @param {TeamsResponseWithoutId} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsPost: async (request: TeamsResponseWithoutId, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('teamsPost', 'request', request)
            const localVarPath = `/teams`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Activate user who is invited the team
         * @param {string} teamId Team ID
         * @param {string} key Activation key which is sent when owner invites other user to the team
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsTeamIdActivationKeyPost: async (teamId: string, key: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('teamsTeamIdActivationKeyPost', 'teamId', teamId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('teamsTeamIdActivationKeyPost', 'key', key)
            const localVarPath = `/teams/{team_id}/activation/{key}`
                .replace(`{${"team_id"}}`, encodeURIComponent(String(teamId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a team
         * @param {string} teamId Team ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsTeamIdDelete: async (teamId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('teamsTeamIdDelete', 'teamId', teamId)
            const localVarPath = `/teams/{team_id}`
                .replace(`{${"team_id"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a details of team
         * @param {string} teamId Team ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsTeamIdGet: async (teamId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('teamsTeamIdGet', 'teamId', teamId)
            const localVarPath = `/teams/{team_id}`
                .replace(`{${"team_id"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List users specified team
         * @param {string} teamId Team ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsTeamIdMembersGet: async (teamId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('teamsTeamIdMembersGet', 'teamId', teamId)
            const localVarPath = `/teams/{team_id}/members`
                .replace(`{${"team_id"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get member information specified team and name
         * @param {string} teamId Team ID
         * @param {string} name Name of a member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsTeamIdMembersNameGet: async (teamId: string, name: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('teamsTeamIdMembersNameGet', 'teamId', teamId)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('teamsTeamIdMembersNameGet', 'name', name)
            const localVarPath = `/teams/{team_id}/members/{name}`
                .replace(`{${"team_id"}}`, encodeURIComponent(String(teamId)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete role of specific team member
         * @param {string} teamId Team ID
         * @param {string} name name of member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsTeamIdMembersNameRoleDelete: async (teamId: string, name: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('teamsTeamIdMembersNameRoleDelete', 'teamId', teamId)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('teamsTeamIdMembersNameRoleDelete', 'name', name)
            const localVarPath = `/teams/{team_id}/members/{name}/role`
                .replace(`{${"team_id"}}`, encodeURIComponent(String(teamId)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get role of specific team member
         * @param {string} teamId Team ID
         * @param {string} name Name of member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsTeamIdMembersNameRoleGet: async (teamId: string, name: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('teamsTeamIdMembersNameRoleGet', 'teamId', teamId)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('teamsTeamIdMembersNameRoleGet', 'name', name)
            const localVarPath = `/teams/{team_id}/members/{name}/role`
                .replace(`{${"team_id"}}`, encodeURIComponent(String(teamId)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add role of specific team member
         * @param {string} teamId Team ID
         * @param {string} name Name of member
         * @param {InlineObject18} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsTeamIdMembersNameRolePost: async (teamId: string, name: string, request: InlineObject18, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('teamsTeamIdMembersNameRolePost', 'teamId', teamId)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('teamsTeamIdMembersNameRolePost', 'name', name)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('teamsTeamIdMembersNameRolePost', 'request', request)
            const localVarPath = `/teams/{team_id}/members/{name}/role`
                .replace(`{${"team_id"}}`, encodeURIComponent(String(teamId)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update role of specific team member
         * @param {string} teamId Team ID
         * @param {string} name name of member
         * @param {InlineObject17} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsTeamIdMembersNameRolePut: async (teamId: string, name: string, request: InlineObject17, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('teamsTeamIdMembersNameRolePut', 'teamId', teamId)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('teamsTeamIdMembersNameRolePut', 'name', name)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('teamsTeamIdMembersNameRolePut', 'request', request)
            const localVarPath = `/teams/{team_id}/members/{name}/role`
                .replace(`{${"team_id"}}`, encodeURIComponent(String(teamId)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add members to the team by email. If new member already has Shifter Account, This API sends invitation to the the user who matched with email. If new member does not have Shifter account yet, API sends invitation to that email with Sign Up link.
         * @param {string} teamId Team ID
         * @param {Array<InlineObject>} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsTeamIdMembersPost: async (teamId: string, request?: Array<InlineObject>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('teamsTeamIdMembersPost', 'teamId', teamId)
            const localVarPath = `/teams/{team_id}/members`
                .replace(`{${"team_id"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a team
         * @param {string} teamId Team ID
         * @param {TeamsResponseWithoutId} request New team information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsTeamIdPut: async (teamId: string, request: TeamsResponseWithoutId, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('teamsTeamIdPut', 'teamId', teamId)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('teamsTeamIdPut', 'request', request)
            const localVarPath = `/teams/{team_id}`
                .replace(`{${"team_id"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Detach sites from specified team
         * @param {string} teamId Team ID
         * @param {InlineObject16} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsTeamIdSitesDelete: async (teamId: string, request?: InlineObject16, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('teamsTeamIdSitesDelete', 'teamId', teamId)
            const localVarPath = `/teams/{team_id}/sites`
                .replace(`{${"team_id"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List sites in specified team
         * @param {string} teamId Team ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsTeamIdSitesGet: async (teamId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('teamsTeamIdSitesGet', 'teamId', teamId)
            const localVarPath = `/teams/{team_id}/sites`
                .replace(`{${"team_id"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add sites to the team
         * @param {string} teamId Team ID
         * @param {InlineObject15} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsTeamIdSitesPost: async (teamId: string, request: InlineObject15, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('teamsTeamIdSitesPost', 'teamId', teamId)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('teamsTeamIdSitesPost', 'request', request)
            const localVarPath = `/teams/{team_id}/sites`
                .replace(`{${"team_id"}}`, encodeURIComponent(String(teamId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get site details which specified team
         * @param {string} teamId Team ID
         * @param {string} siteId Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsTeamIdSitesSiteIdGet: async (teamId: string, siteId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('teamsTeamIdSitesSiteIdGet', 'teamId', teamId)
            // verify required parameter 'siteId' is not null or undefined
            assertParamExists('teamsTeamIdSitesSiteIdGet', 'siteId', siteId)
            const localVarPath = `/teams/{team_id}/sites/{site_id}`
                .replace(`{${"team_id"}}`, encodeURIComponent(String(teamId)))
                .replace(`{${"site_id"}}`, encodeURIComponent(String(siteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a site to specific team
         * @param {string} teamId Team ID
         * @param {string} siteId Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsTeamIdSitesSiteIdPost: async (teamId: string, siteId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'teamId' is not null or undefined
            assertParamExists('teamsTeamIdSitesSiteIdPost', 'teamId', teamId)
            // verify required parameter 'siteId' is not null or undefined
            assertParamExists('teamsTeamIdSitesSiteIdPost', 'siteId', siteId)
            const localVarPath = `/teams/{team_id}/sites/{site_id}`
                .replace(`{${"team_id"}}`, encodeURIComponent(String(teamId)))
                .replace(`{${"site_id"}}`, encodeURIComponent(String(siteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TeamsApi - functional programming interface
 * @export
 */
export const TeamsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TeamsApiAxiosParamCreator(configuration)
    return {
        /**
         * List teams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamsGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List teams which member belongs into
         * @param {string} memberName Member\&#39;s name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamsMembersMemberNameTeamsGet(memberName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2002>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamsMembersMemberNameTeamsGet(memberName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a team
         * @param {TeamsResponseWithoutId} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamsPost(request: TeamsResponseWithoutId, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2012>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamsPost(request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Activate user who is invited the team
         * @param {string} teamId Team ID
         * @param {string} key Activation key which is sent when owner invites other user to the team
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamsTeamIdActivationKeyPost(teamId: string, key: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamsTeamIdActivationKeyPost(teamId, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a team
         * @param {string} teamId Team ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamsTeamIdDelete(teamId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamsTeamIdDelete(teamId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a details of team
         * @param {string} teamId Team ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamsTeamIdGet(teamId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeamsResponseWithId>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamsTeamIdGet(teamId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List users specified team
         * @param {string} teamId Team ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamsTeamIdMembersGet(teamId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse2003>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamsTeamIdMembersGet(teamId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get member information specified team and name
         * @param {string} teamId Team ID
         * @param {string} name Name of a member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamsTeamIdMembersNameGet(teamId: string, name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2004>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamsTeamIdMembersNameGet(teamId, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete role of specific team member
         * @param {string} teamId Team ID
         * @param {string} name name of member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamsTeamIdMembersNameRoleDelete(teamId: string, name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamsTeamIdMembersNameRoleDelete(teamId, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get role of specific team member
         * @param {string} teamId Team ID
         * @param {string} name Name of member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamsTeamIdMembersNameRoleGet(teamId: string, name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2005>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamsTeamIdMembersNameRoleGet(teamId, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add role of specific team member
         * @param {string} teamId Team ID
         * @param {string} name Name of member
         * @param {InlineObject18} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamsTeamIdMembersNameRolePost(teamId: string, name: string, request: InlineObject18, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamsTeamIdMembersNameRolePost(teamId, name, request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update role of specific team member
         * @param {string} teamId Team ID
         * @param {string} name name of member
         * @param {InlineObject17} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamsTeamIdMembersNameRolePut(teamId: string, name: string, request: InlineObject17, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamsTeamIdMembersNameRolePut(teamId, name, request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add members to the team by email. If new member already has Shifter Account, This API sends invitation to the the user who matched with email. If new member does not have Shifter account yet, API sends invitation to that email with Sign Up link.
         * @param {string} teamId Team ID
         * @param {Array<InlineObject>} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamsTeamIdMembersPost(teamId: string, request?: Array<InlineObject>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamsTeamIdMembersPost(teamId, request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a team
         * @param {string} teamId Team ID
         * @param {TeamsResponseWithoutId} request New team information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamsTeamIdPut(teamId: string, request: TeamsResponseWithoutId, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamsTeamIdPut(teamId, request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Detach sites from specified team
         * @param {string} teamId Team ID
         * @param {InlineObject16} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamsTeamIdSitesDelete(teamId: string, request?: InlineObject16, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamsTeamIdSitesDelete(teamId, request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List sites in specified team
         * @param {string} teamId Team ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamsTeamIdSitesGet(teamId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SiteResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamsTeamIdSitesGet(teamId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add sites to the team
         * @param {string} teamId Team ID
         * @param {InlineObject15} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamsTeamIdSitesPost(teamId: string, request: InlineObject15, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamsTeamIdSitesPost(teamId, request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get site details which specified team
         * @param {string} teamId Team ID
         * @param {string} siteId Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamsTeamIdSitesSiteIdGet(teamId: string, siteId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SiteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamsTeamIdSitesSiteIdGet(teamId, siteId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add a site to specific team
         * @param {string} teamId Team ID
         * @param {string} siteId Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async teamsTeamIdSitesSiteIdPost(teamId: string, siteId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.teamsTeamIdSitesSiteIdPost(teamId, siteId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TeamsApi - factory interface
 * @export
 */
export const TeamsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TeamsApiFp(configuration)
    return {
        /**
         * List teams
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsGet(options?: any): AxiosPromise<InlineResponse2001> {
            return localVarFp.teamsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * List teams which member belongs into
         * @param {string} memberName Member\&#39;s name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsMembersMemberNameTeamsGet(memberName: string, options?: any): AxiosPromise<InlineResponse2002> {
            return localVarFp.teamsMembersMemberNameTeamsGet(memberName, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a team
         * @param {TeamsResponseWithoutId} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsPost(request: TeamsResponseWithoutId, options?: any): AxiosPromise<InlineResponse2012> {
            return localVarFp.teamsPost(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Activate user who is invited the team
         * @param {string} teamId Team ID
         * @param {string} key Activation key which is sent when owner invites other user to the team
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsTeamIdActivationKeyPost(teamId: string, key: string, options?: any): AxiosPromise<void> {
            return localVarFp.teamsTeamIdActivationKeyPost(teamId, key, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a team
         * @param {string} teamId Team ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsTeamIdDelete(teamId: string, options?: any): AxiosPromise<void> {
            return localVarFp.teamsTeamIdDelete(teamId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a details of team
         * @param {string} teamId Team ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsTeamIdGet(teamId: string, options?: any): AxiosPromise<TeamsResponseWithId> {
            return localVarFp.teamsTeamIdGet(teamId, options).then((request) => request(axios, basePath));
        },
        /**
         * List users specified team
         * @param {string} teamId Team ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsTeamIdMembersGet(teamId: string, options?: any): AxiosPromise<Array<InlineResponse2003>> {
            return localVarFp.teamsTeamIdMembersGet(teamId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get member information specified team and name
         * @param {string} teamId Team ID
         * @param {string} name Name of a member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsTeamIdMembersNameGet(teamId: string, name: string, options?: any): AxiosPromise<InlineResponse2004> {
            return localVarFp.teamsTeamIdMembersNameGet(teamId, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete role of specific team member
         * @param {string} teamId Team ID
         * @param {string} name name of member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsTeamIdMembersNameRoleDelete(teamId: string, name: string, options?: any): AxiosPromise<void> {
            return localVarFp.teamsTeamIdMembersNameRoleDelete(teamId, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Get role of specific team member
         * @param {string} teamId Team ID
         * @param {string} name Name of member
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsTeamIdMembersNameRoleGet(teamId: string, name: string, options?: any): AxiosPromise<InlineResponse2005> {
            return localVarFp.teamsTeamIdMembersNameRoleGet(teamId, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Add role of specific team member
         * @param {string} teamId Team ID
         * @param {string} name Name of member
         * @param {InlineObject18} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsTeamIdMembersNameRolePost(teamId: string, name: string, request: InlineObject18, options?: any): AxiosPromise<void> {
            return localVarFp.teamsTeamIdMembersNameRolePost(teamId, name, request, options).then((request) => request(axios, basePath));
        },
        /**
         * Update role of specific team member
         * @param {string} teamId Team ID
         * @param {string} name name of member
         * @param {InlineObject17} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsTeamIdMembersNameRolePut(teamId: string, name: string, request: InlineObject17, options?: any): AxiosPromise<void> {
            return localVarFp.teamsTeamIdMembersNameRolePut(teamId, name, request, options).then((request) => request(axios, basePath));
        },
        /**
         * Add members to the team by email. If new member already has Shifter Account, This API sends invitation to the the user who matched with email. If new member does not have Shifter account yet, API sends invitation to that email with Sign Up link.
         * @param {string} teamId Team ID
         * @param {Array<InlineObject>} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsTeamIdMembersPost(teamId: string, request?: Array<InlineObject>, options?: any): AxiosPromise<void> {
            return localVarFp.teamsTeamIdMembersPost(teamId, request, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a team
         * @param {string} teamId Team ID
         * @param {TeamsResponseWithoutId} request New team information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsTeamIdPut(teamId: string, request: TeamsResponseWithoutId, options?: any): AxiosPromise<void> {
            return localVarFp.teamsTeamIdPut(teamId, request, options).then((request) => request(axios, basePath));
        },
        /**
         * Detach sites from specified team
         * @param {string} teamId Team ID
         * @param {InlineObject16} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsTeamIdSitesDelete(teamId: string, request?: InlineObject16, options?: any): AxiosPromise<void> {
            return localVarFp.teamsTeamIdSitesDelete(teamId, request, options).then((request) => request(axios, basePath));
        },
        /**
         * List sites in specified team
         * @param {string} teamId Team ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsTeamIdSitesGet(teamId: string, options?: any): AxiosPromise<Array<SiteResponse>> {
            return localVarFp.teamsTeamIdSitesGet(teamId, options).then((request) => request(axios, basePath));
        },
        /**
         * Add sites to the team
         * @param {string} teamId Team ID
         * @param {InlineObject15} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsTeamIdSitesPost(teamId: string, request: InlineObject15, options?: any): AxiosPromise<void> {
            return localVarFp.teamsTeamIdSitesPost(teamId, request, options).then((request) => request(axios, basePath));
        },
        /**
         * Get site details which specified team
         * @param {string} teamId Team ID
         * @param {string} siteId Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsTeamIdSitesSiteIdGet(teamId: string, siteId: string, options?: any): AxiosPromise<SiteResponse> {
            return localVarFp.teamsTeamIdSitesSiteIdGet(teamId, siteId, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a site to specific team
         * @param {string} teamId Team ID
         * @param {string} siteId Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        teamsTeamIdSitesSiteIdPost(teamId: string, siteId: string, options?: any): AxiosPromise<void> {
            return localVarFp.teamsTeamIdSitesSiteIdPost(teamId, siteId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TeamsApi - object-oriented interface
 * @export
 * @class TeamsApi
 * @extends {BaseAPI}
 */
export class TeamsApi extends BaseAPI {
    /**
     * List teams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public teamsGet(options?: any) {
        return TeamsApiFp(this.configuration).teamsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List teams which member belongs into
     * @param {string} memberName Member\&#39;s name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public teamsMembersMemberNameTeamsGet(memberName: string, options?: any) {
        return TeamsApiFp(this.configuration).teamsMembersMemberNameTeamsGet(memberName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a team
     * @param {TeamsResponseWithoutId} request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public teamsPost(request: TeamsResponseWithoutId, options?: any) {
        return TeamsApiFp(this.configuration).teamsPost(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Activate user who is invited the team
     * @param {string} teamId Team ID
     * @param {string} key Activation key which is sent when owner invites other user to the team
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public teamsTeamIdActivationKeyPost(teamId: string, key: string, options?: any) {
        return TeamsApiFp(this.configuration).teamsTeamIdActivationKeyPost(teamId, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a team
     * @param {string} teamId Team ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public teamsTeamIdDelete(teamId: string, options?: any) {
        return TeamsApiFp(this.configuration).teamsTeamIdDelete(teamId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a details of team
     * @param {string} teamId Team ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public teamsTeamIdGet(teamId: string, options?: any) {
        return TeamsApiFp(this.configuration).teamsTeamIdGet(teamId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List users specified team
     * @param {string} teamId Team ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public teamsTeamIdMembersGet(teamId: string, options?: any) {
        return TeamsApiFp(this.configuration).teamsTeamIdMembersGet(teamId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get member information specified team and name
     * @param {string} teamId Team ID
     * @param {string} name Name of a member
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public teamsTeamIdMembersNameGet(teamId: string, name: string, options?: any) {
        return TeamsApiFp(this.configuration).teamsTeamIdMembersNameGet(teamId, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete role of specific team member
     * @param {string} teamId Team ID
     * @param {string} name name of member
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public teamsTeamIdMembersNameRoleDelete(teamId: string, name: string, options?: any) {
        return TeamsApiFp(this.configuration).teamsTeamIdMembersNameRoleDelete(teamId, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get role of specific team member
     * @param {string} teamId Team ID
     * @param {string} name Name of member
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public teamsTeamIdMembersNameRoleGet(teamId: string, name: string, options?: any) {
        return TeamsApiFp(this.configuration).teamsTeamIdMembersNameRoleGet(teamId, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add role of specific team member
     * @param {string} teamId Team ID
     * @param {string} name Name of member
     * @param {InlineObject18} request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public teamsTeamIdMembersNameRolePost(teamId: string, name: string, request: InlineObject18, options?: any) {
        return TeamsApiFp(this.configuration).teamsTeamIdMembersNameRolePost(teamId, name, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update role of specific team member
     * @param {string} teamId Team ID
     * @param {string} name name of member
     * @param {InlineObject17} request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public teamsTeamIdMembersNameRolePut(teamId: string, name: string, request: InlineObject17, options?: any) {
        return TeamsApiFp(this.configuration).teamsTeamIdMembersNameRolePut(teamId, name, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add members to the team by email. If new member already has Shifter Account, This API sends invitation to the the user who matched with email. If new member does not have Shifter account yet, API sends invitation to that email with Sign Up link.
     * @param {string} teamId Team ID
     * @param {Array<InlineObject>} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public teamsTeamIdMembersPost(teamId: string, request?: Array<InlineObject>, options?: any) {
        return TeamsApiFp(this.configuration).teamsTeamIdMembersPost(teamId, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a team
     * @param {string} teamId Team ID
     * @param {TeamsResponseWithoutId} request New team information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public teamsTeamIdPut(teamId: string, request: TeamsResponseWithoutId, options?: any) {
        return TeamsApiFp(this.configuration).teamsTeamIdPut(teamId, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Detach sites from specified team
     * @param {string} teamId Team ID
     * @param {InlineObject16} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public teamsTeamIdSitesDelete(teamId: string, request?: InlineObject16, options?: any) {
        return TeamsApiFp(this.configuration).teamsTeamIdSitesDelete(teamId, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List sites in specified team
     * @param {string} teamId Team ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public teamsTeamIdSitesGet(teamId: string, options?: any) {
        return TeamsApiFp(this.configuration).teamsTeamIdSitesGet(teamId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add sites to the team
     * @param {string} teamId Team ID
     * @param {InlineObject15} request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public teamsTeamIdSitesPost(teamId: string, request: InlineObject15, options?: any) {
        return TeamsApiFp(this.configuration).teamsTeamIdSitesPost(teamId, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get site details which specified team
     * @param {string} teamId Team ID
     * @param {string} siteId Site ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public teamsTeamIdSitesSiteIdGet(teamId: string, siteId: string, options?: any) {
        return TeamsApiFp(this.configuration).teamsTeamIdSitesSiteIdGet(teamId, siteId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add a site to specific team
     * @param {string} teamId Team ID
     * @param {string} siteId Site ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TeamsApi
     */
    public teamsTeamIdSitesSiteIdPost(teamId: string, siteId: string, options?: any) {
        return TeamsApiFp(this.configuration).teamsTeamIdSitesSiteIdPost(teamId, siteId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WebhooksApi - axios parameter creator
 * @export
 */
export const WebhooksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete webhooks
         * @param {string} siteId Site ID
         * @param {InlineObject21} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksSiteSiteIdDelete: async (siteId: string, request: InlineObject21, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteId' is not null or undefined
            assertParamExists('webhooksSiteSiteIdDelete', 'siteId', siteId)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('webhooksSiteSiteIdDelete', 'request', request)
            const localVarPath = `/webhooks/site/{site_id}`
                .replace(`{${"site_id"}}`, encodeURIComponent(String(siteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get webhooks
         * @param {string} siteId Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksSiteSiteIdGet: async (siteId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteId' is not null or undefined
            assertParamExists('webhooksSiteSiteIdGet', 'siteId', siteId)
            const localVarPath = `/webhooks/site/{site_id}`
                .replace(`{${"site_id"}}`, encodeURIComponent(String(siteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List webhook history
         * @param {string} siteId Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksSiteSiteIdHistoryGet: async (siteId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteId' is not null or undefined
            assertParamExists('webhooksSiteSiteIdHistoryGet', 'siteId', siteId)
            const localVarPath = `/webhooks/site/{site_id}/history`
                .replace(`{${"site_id"}}`, encodeURIComponent(String(siteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create webhooks
         * @param {string} siteId Site ID
         * @param {InlineObject20} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksSiteSiteIdPost: async (siteId: string, request: InlineObject20, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteId' is not null or undefined
            assertParamExists('webhooksSiteSiteIdPost', 'siteId', siteId)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('webhooksSiteSiteIdPost', 'request', request)
            const localVarPath = `/webhooks/site/{site_id}`
                .replace(`{${"site_id"}}`, encodeURIComponent(String(siteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update webhooks
         * @param {string} siteId Site ID
         * @param {InlineObject19} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksSiteSiteIdPut: async (siteId: string, request: InlineObject19, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteId' is not null or undefined
            assertParamExists('webhooksSiteSiteIdPut', 'siteId', siteId)
            // verify required parameter 'request' is not null or undefined
            assertParamExists('webhooksSiteSiteIdPut', 'request', request)
            const localVarPath = `/webhooks/site/{site_id}`
                .replace(`{${"site_id"}}`, encodeURIComponent(String(siteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebhooksApi - functional programming interface
 * @export
 */
export const WebhooksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WebhooksApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete webhooks
         * @param {string} siteId Site ID
         * @param {InlineObject21} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhooksSiteSiteIdDelete(siteId: string, request: InlineObject21, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse2006>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhooksSiteSiteIdDelete(siteId, request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get webhooks
         * @param {string} siteId Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhooksSiteSiteIdGet(siteId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse2006>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhooksSiteSiteIdGet(siteId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List webhook history
         * @param {string} siteId Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhooksSiteSiteIdHistoryGet(siteId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse2007>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhooksSiteSiteIdHistoryGet(siteId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create webhooks
         * @param {string} siteId Site ID
         * @param {InlineObject20} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhooksSiteSiteIdPost(siteId: string, request: InlineObject20, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse2006>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhooksSiteSiteIdPost(siteId, request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update webhooks
         * @param {string} siteId Site ID
         * @param {InlineObject19} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webhooksSiteSiteIdPut(siteId: string, request: InlineObject19, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse2006>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webhooksSiteSiteIdPut(siteId, request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WebhooksApi - factory interface
 * @export
 */
export const WebhooksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WebhooksApiFp(configuration)
    return {
        /**
         * Delete webhooks
         * @param {string} siteId Site ID
         * @param {InlineObject21} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksSiteSiteIdDelete(siteId: string, request: InlineObject21, options?: any): AxiosPromise<Array<InlineResponse2006>> {
            return localVarFp.webhooksSiteSiteIdDelete(siteId, request, options).then((request) => request(axios, basePath));
        },
        /**
         * Get webhooks
         * @param {string} siteId Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksSiteSiteIdGet(siteId: string, options?: any): AxiosPromise<Array<InlineResponse2006>> {
            return localVarFp.webhooksSiteSiteIdGet(siteId, options).then((request) => request(axios, basePath));
        },
        /**
         * List webhook history
         * @param {string} siteId Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksSiteSiteIdHistoryGet(siteId: string, options?: any): AxiosPromise<Array<InlineResponse2007>> {
            return localVarFp.webhooksSiteSiteIdHistoryGet(siteId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create webhooks
         * @param {string} siteId Site ID
         * @param {InlineObject20} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksSiteSiteIdPost(siteId: string, request: InlineObject20, options?: any): AxiosPromise<Array<InlineResponse2006>> {
            return localVarFp.webhooksSiteSiteIdPost(siteId, request, options).then((request) => request(axios, basePath));
        },
        /**
         * Update webhooks
         * @param {string} siteId Site ID
         * @param {InlineObject19} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webhooksSiteSiteIdPut(siteId: string, request: InlineObject19, options?: any): AxiosPromise<Array<InlineResponse2006>> {
            return localVarFp.webhooksSiteSiteIdPut(siteId, request, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WebhooksApi - object-oriented interface
 * @export
 * @class WebhooksApi
 * @extends {BaseAPI}
 */
export class WebhooksApi extends BaseAPI {
    /**
     * Delete webhooks
     * @param {string} siteId Site ID
     * @param {InlineObject21} request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public webhooksSiteSiteIdDelete(siteId: string, request: InlineObject21, options?: any) {
        return WebhooksApiFp(this.configuration).webhooksSiteSiteIdDelete(siteId, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get webhooks
     * @param {string} siteId Site ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public webhooksSiteSiteIdGet(siteId: string, options?: any) {
        return WebhooksApiFp(this.configuration).webhooksSiteSiteIdGet(siteId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List webhook history
     * @param {string} siteId Site ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public webhooksSiteSiteIdHistoryGet(siteId: string, options?: any) {
        return WebhooksApiFp(this.configuration).webhooksSiteSiteIdHistoryGet(siteId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create webhooks
     * @param {string} siteId Site ID
     * @param {InlineObject20} request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public webhooksSiteSiteIdPost(siteId: string, request: InlineObject20, options?: any) {
        return WebhooksApiFp(this.configuration).webhooksSiteSiteIdPost(siteId, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update webhooks
     * @param {string} siteId Site ID
     * @param {InlineObject19} request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApi
     */
    public webhooksSiteSiteIdPut(siteId: string, request: InlineObject19, options?: any) {
        return WebhooksApiFp(this.configuration).webhooksSiteSiteIdPut(siteId, request, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WordPressApi - axios parameter creator
 * @export
 */
export const WordPressApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Start WordPress
         * @param {string} siteId Site ID
         * @param {string} notificationId Notification ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdWordpressSiteCheckWpSetupNotificationIdGet: async (siteId: string, notificationId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteId' is not null or undefined
            assertParamExists('sitesSiteIdWordpressSiteCheckWpSetupNotificationIdGet', 'siteId', siteId)
            // verify required parameter 'notificationId' is not null or undefined
            assertParamExists('sitesSiteIdWordpressSiteCheckWpSetupNotificationIdGet', 'notificationId', notificationId)
            const localVarPath = `/sites/{site_id}/wordpress_site/check_wp_setup/{notification_id}`
                .replace(`{${"site_id"}}`, encodeURIComponent(String(siteId)))
                .replace(`{${"notification_id"}}`, encodeURIComponent(String(notificationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get errors of WordPress container
         * @param {string} siteId Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdWordpressSiteErrorsGet: async (siteId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteId' is not null or undefined
            assertParamExists('sitesSiteIdWordpressSiteErrorsGet', 'siteId', siteId)
            const localVarPath = `/sites/{site_id}/wordpress_site/errors`
                .replace(`{${"site_id"}}`, encodeURIComponent(String(siteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Start WordPress
         * @param {string} siteId Site ID
         * @param {InlineObject4} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdWordpressSiteStartPost: async (siteId: string, request?: InlineObject4, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteId' is not null or undefined
            assertParamExists('sitesSiteIdWordpressSiteStartPost', 'siteId', siteId)
            const localVarPath = `/sites/{site_id}/wordpress_site/start`
                .replace(`{${"site_id"}}`, encodeURIComponent(String(siteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stop WordPress
         * @param {string} siteId Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdWordpressSiteStopPost: async (siteId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'siteId' is not null or undefined
            assertParamExists('sitesSiteIdWordpressSiteStopPost', 'siteId', siteId)
            const localVarPath = `/sites/{site_id}/wordpress_site/stop`
                .replace(`{${"site_id"}}`, encodeURIComponent(String(siteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WordPressApi - functional programming interface
 * @export
 */
export const WordPressApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WordPressApiAxiosParamCreator(configuration)
    return {
        /**
         * Start WordPress
         * @param {string} siteId Site ID
         * @param {string} notificationId Notification ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitesSiteIdWordpressSiteCheckWpSetupNotificationIdGet(siteId: string, notificationId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitesSiteIdWordpressSiteCheckWpSetupNotificationIdGet(siteId, notificationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get errors of WordPress container
         * @param {string} siteId Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitesSiteIdWordpressSiteErrorsGet(siteId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitesSiteIdWordpressSiteErrorsGet(siteId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Start WordPress
         * @param {string} siteId Site ID
         * @param {InlineObject4} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitesSiteIdWordpressSiteStartPost(siteId: string, request?: InlineObject4, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse201>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitesSiteIdWordpressSiteStartPost(siteId, request, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Stop WordPress
         * @param {string} siteId Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sitesSiteIdWordpressSiteStopPost(siteId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2011>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sitesSiteIdWordpressSiteStopPost(siteId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WordPressApi - factory interface
 * @export
 */
export const WordPressApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WordPressApiFp(configuration)
    return {
        /**
         * Start WordPress
         * @param {string} siteId Site ID
         * @param {string} notificationId Notification ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdWordpressSiteCheckWpSetupNotificationIdGet(siteId: string, notificationId: string, options?: any): AxiosPromise<string> {
            return localVarFp.sitesSiteIdWordpressSiteCheckWpSetupNotificationIdGet(siteId, notificationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get errors of WordPress container
         * @param {string} siteId Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdWordpressSiteErrorsGet(siteId: string, options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.sitesSiteIdWordpressSiteErrorsGet(siteId, options).then((request) => request(axios, basePath));
        },
        /**
         * Start WordPress
         * @param {string} siteId Site ID
         * @param {InlineObject4} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdWordpressSiteStartPost(siteId: string, request?: InlineObject4, options?: any): AxiosPromise<InlineResponse201> {
            return localVarFp.sitesSiteIdWordpressSiteStartPost(siteId, request, options).then((request) => request(axios, basePath));
        },
        /**
         * Stop WordPress
         * @param {string} siteId Site ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sitesSiteIdWordpressSiteStopPost(siteId: string, options?: any): AxiosPromise<InlineResponse2011> {
            return localVarFp.sitesSiteIdWordpressSiteStopPost(siteId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WordPressApi - object-oriented interface
 * @export
 * @class WordPressApi
 * @extends {BaseAPI}
 */
export class WordPressApi extends BaseAPI {
    /**
     * Start WordPress
     * @param {string} siteId Site ID
     * @param {string} notificationId Notification ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WordPressApi
     */
    public sitesSiteIdWordpressSiteCheckWpSetupNotificationIdGet(siteId: string, notificationId: string, options?: any) {
        return WordPressApiFp(this.configuration).sitesSiteIdWordpressSiteCheckWpSetupNotificationIdGet(siteId, notificationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get errors of WordPress container
     * @param {string} siteId Site ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WordPressApi
     */
    public sitesSiteIdWordpressSiteErrorsGet(siteId: string, options?: any) {
        return WordPressApiFp(this.configuration).sitesSiteIdWordpressSiteErrorsGet(siteId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Start WordPress
     * @param {string} siteId Site ID
     * @param {InlineObject4} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WordPressApi
     */
    public sitesSiteIdWordpressSiteStartPost(siteId: string, request?: InlineObject4, options?: any) {
        return WordPressApiFp(this.configuration).sitesSiteIdWordpressSiteStartPost(siteId, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Stop WordPress
     * @param {string} siteId Site ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WordPressApi
     */
    public sitesSiteIdWordpressSiteStopPost(siteId: string, options?: any) {
        return WordPressApiFp(this.configuration).sitesSiteIdWordpressSiteStopPost(siteId, options).then((request) => request(this.axios, this.basePath));
    }
}


